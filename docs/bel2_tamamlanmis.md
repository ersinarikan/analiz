

T.C.
İSTANBUL OKAN ÜNİVERSİTESİ
LİSANSÜSTÜ EĞİTİM ENSTİTÜSÜ



YÜKSEK LİSANS TEZİ
BİLİŞİM SİSTEMLERİ ANABİLİM DALI

Ersin ARIKAN
YAPAY ZEKA DESTEKLİ GÖRSEL ve VİDEO İÇERİK ANALİZİ: TOPLUMSAL DEĞERLERİN KORUNMASI İÇİN ÖĞRENEN BİR UYGULAMA



DANIŞMAN
Dr. Öğr. Üyesi Ender ŞAHİNASLAN




İSTANBUL, Aralık 2025
İÇİNDEKİLER
ÖNSÖZ	4
ÖZET	5
SUMMARY	6
KISALTMALAR	8
ŞEKİL LİSTESİ	9
TABLO LİSTESİ	10
BÖLÜM 1 GİRİŞ ve AMAÇ	11
1.1.	PROBLEM TANIMI ve MOTİVASYON	11
1.2.	TEZİN AMACI ve HEDEFLER	11
1.3.	KAPSAM ve KATKILAR	12
1.4.	PROJE GELİŞTİRME SÜRECİ ve ZAMAN ÇİZELGESİ	13
BÖLÜM 2 GENEL BİLGİLER VE LİTERATÜR	15
2.1. BİLGİSAYARLI GÖRÜ ve İÇERİK ANALİZİ TEMELLERİ	15
2.2. TRANSFER/ARTIMSAL ÖĞRENME YAKLAŞIMLARI	16
2.3. VERİ KALİTESİ ve GÜVEN SKORLAMA	18
2.4. UYGULAMA ODAKLI ÇALIŞMALAR ve BOŞLUK ANALİZİ	20
2.5. İÇERİK MODERASYONU ve ÇOK MODELLİ YAKLAŞIMLAR	22
BÖLÜM 3 SİSTEM ve MİMARİ	24
3.1. GENEL MİMARİ	24
3.2. UYGULAMA YAŞAM DÖNGÜSÜ	24
3.3. KONFİGÜRASYON SABİTLER, DURUM ve YOL HİYERARŞİSİ	25
3.4. GÜNCELLENEBİLİR ANALİZ PARAMETRELERİ ve MODEL DURUMU	26
3.5. VARLIK İLİŞKİ MODELİ ve DOSYA YÖNETİMİ	27
3.6. PLAFORM, UYGULAMA YAYINLAMA KATMANI	29




ÖNSÖZ
Bu çalışma, kurum içi gereksinimlerden doğan gerçek bir yazılım ürününün araştırma ve geliştirme sürecine dayanır. Geliştirme boyunca kararların teknik ve kurumsal dayanakları dikkatle belgelenmiş, her adımda etik, güvenlik ve gizlilik ilkeleri gözetilmiştir. 
Bu sürece katkı veren tüm meslektaşlarıma ve değerli danışmanım Dr. Öğr. Üyesi Ender Şahinaslan'a teşekkürlerimi ve saygılarımı sunarım.


Ersin ARIKAN
İSTANBUL, 2025



ÖZET
YAPAY ZEKA DESTEKLİ GÖRSEL ve VİDEO İÇERİK ANALİZİ: TOPLUMSAL DEĞERLERİN KORUNMASI İÇİN ÖĞRENEN BİR UYGULAMA
Bu tezde, yüksek hacimli görsel ve video içeriğini anlamak ve kurumsal değerlendirme kriterleri için içeriği otomatik ve yarı otomatik olarak analiz etmeyi amaçlayan bir yazılım sistemi geliştirilmiştir. Sistem, sosyal medya, televizyon yayınları ve çeşitli internet kaynaklarından elde edilen içeriğin, çocukların zihinsel gelişimi ve toplumun ahlaki değerleri üzerindeki risklerini standart bir şekilde hızlı ve tutarlı bir şekilde tanımlamayı hedeflemektedir. Uygulama, içeriği sınıflandırmak için OpenCLIP'i, nesne/kişiyi tespit etmek için YOLO'yu, yüz analizi için ise InsightFace'i entegre eden bir Python arka uç mimarisine dayanmaktadır. Depolama, kuyruklama, gerçek zamanlı bildirimler ve diğer alt sistemlerin yapılandırması, üretim ortamına uygun ölçeklenebilir, yeniden başlatılabilir ve operasyonel olarak kontrol edilen bir iş akışını destekleyecek şekilde tasarlanmıştır. Sistem tasarımının ayırt edici özelliği, uzmanlardan alınan geri bildirimler ve yüksek güvenilirlikteki sahte etiketler kullanılarak artımlı öğrenme döngülerinin kapatılmasıdır. Bu amaçla, metin-görüntü tabanlı anlamsal doğrulamayı, birden fazla modelde güvenilir çapraz model çıktı tutarlılığı ile entegre eden bir güven puanı yöntemi önerilmektedir. Bu, OpenCLIP tarafından üretilen olumlu/olumsuz isteme dayalı benzerlik metrikleri ve iki model arasındaki tahminlerin yakınlığını dikkate alarak yapılmaktadır. Bu şekilde, gürültülü akışlarla zayıf denetimli çerçeveler, hızlı artımlı güncellemelere olanak tanıyarak kullanılabilir hale gelmektedir. Bu, rafine kriterlere dayanan bir analiz için güvenilir bir alt kümenin ortaya çıkmasıyla gerçekleştirilmiştir.
Çalışmanın ön denemeleri için, sapma ±5 yıl olmak üzere, doğruluk, MAE/MSE ve işlem süresi gibi ölçütlerle yapılan değerlendirmeler, hafif başlıkların, yüksek güvenli altkümelerle eğitildiği dönemde, tüm verilere göre eğitime daha kısa sürede, daha tutarlı sonuçlar verdiğini göstermektedir. Mimari, kuruma-gereksinim (on-premises) dağıtım ve veri gizliliği gereksinimlerini karşıladığından, uygulama değerini, üretim koşullarında, sürdürülebilir sürümleme ve geri dönüş (rollback) süreçleri ile birlikte, yanıt verme ölçüte eklemektedir. Yine, bu çalışma, içerik değerlendirmede, tutarlılığı artıran, zaman kazancı sağlayan ve insan yükünü azaltan bir arka uç çözümü sunduğunu belirtmektedir. Tüm bunlar, Türkçe bağlama özgü davranış farklılıklarını dikkate alan yerelleştirme olanakları ile birlikte, çalışmanın, literatürdeki boşluklara katkı sunduğunu göstermektedir.




Anahtar Kelimeler: Görsel içerik analizi, OpenCLIP, InsightFace, artımsal öğrenme, güven skoru, Socket.IO, Python, Flask
Tarih: Aralık 2025

SUMMARY
ARTIFICIAL INTELLIGENCE-SUPPORTED VISUAL AND VIDEO CONTENT ANALYSIS: A LEARNING APPLICATION FOR THE PROTECTION OF SOCIAL VALUES
In this thesis, a software system is developed to understand high-volume visual and video content and analyze it automatically and semi-automatically for institutional evaluation criteria. The system aims to quickly and consistently identify the risks of content obtained from social media, television broadcasts, and various internet sources on children's cognitive development and society's moral values ​​in a standardized manner. The application is based on a Python backend architecture that integrates OpenCLIP for content classification, YOLO for object/person detection, and InsightFace for face analysis. The configuration of storage, queuing, real-time notifications, and other subsystems is designed to support a scalable, replayable, and operationally controlled workflow suitable for production environments. A distinguishing feature of the system design is the closure of incremental learning loops using expert feedback and high-confidence pseudo-labels. To this end, a confidence score method is proposed that integrates text-image-based semantic verification with reliable cross-model output consistency across multiple models. This is achieved by considering similarity metrics based on positive/negative claims generated by OpenCLIP and the closeness of predictions between the two models. This allows for rapid incremental updates to noisy streams, making weakly supervised frameworks usable. This has been achieved by creating a reliable subset for analysis based on refined criteria.
Evaluations of metrics such as accuracy, MAE/MSE, and processing time, with a ±5-year deviation for preliminary tests, indicate that lightweight titles, when trained with high-confidence subsets, yield more consistent results in a shorter training time than the entire dataset. Because the architecture meets on-premises deployment and data privacy requirements, it adds responsiveness to the metric, along with sustainable versioning and rollback processes under production conditions. Furthermore, this study demonstrates that it offers a back-end solution for content evaluation that increases consistency, saves time, and reduces human overhead. All of this, along with localization capabilities that address behavioral differences specific to the Turkish context, demonstrates that the study contributes to gaps in the literature.


Keywords: Visual content analysis, OpenCLIP, InsightFace, incremental learning, confidence scoring, Socket.IO, Python, Flask
Date: December 2025

SEMBOLLER



KISALTMALAR
API: Application Programming Interface  
MAE: Mean Absolute Error  
MSE: Mean Squared Error  
ROC: Receiver Operating Characteristic  
REST: Representational State Transfer



ŞEKİL LİSTESİ
Şekil 1.2. Proje Takvimi	14
Şekil 3.5. Veri Tabanı ER Diyagramı	28



TABLO LİSTESİ



BÖLÜM 1 GİRİŞ ve AMAÇ
 PROBLEM TANIMI ve MOTİVASYON
Son 20-25 yıl içinde dijital içerik üretiminin miktar ve çeşitlilik bakımından büyüyünce, bu alanda düzenleyici ve denetleyici yetkisi bulunan kamu otoritelerine (RTÜK, BTK, Aile ve Sosyal Hizmetler Bakanlığı vb.) yeni görev ve sorumluluklar da eklenmiştir. Bu durum, daha çok görsel ve video tabanlı içeriklerin toplumsal değerlere, hukuka ve kurumsal normlara uygun olup olmadığının, belirli eksenler ve standart yöntemlerle, nicelik ve nitelik kriterleri içinde, kapsamlı ve sistematik olarak, değerlendirilmesi gereğini doğurmuştur. Nitelik ölçütlerine odaklanarak sınırları belirlenemeyen ve sistematik olmayan mevcut uygulamalarda ise, özellikle televizyon, sosyal medya ve diğer çevrimiçi platformlardan yayımlanan içeriklerin yoğun akışı, “güvenli”, “zararlı”, “yetişkin”, “şiddet”, “silah”, “istismar” ve “madde kullanımı” gibi kategorilerde sınıflandırılması gerekliliğini göz ardı etmiştir. Özellikle uzman görüşlerine dayanarak değerlendirilen şiddet içerikli yayınlar ve çocuk istismarı gibi hassas içeriklerde yoğun içerik akışı nedeniyle sınıflandırmalarda büyük tutarsızlıklar gözlemlenmektedir. Bu durum, standart, sürekli ve daha otomatikleştirilmiş yöntemlerin ve yeni sınıflama metodolojilerinin geliştirilmesi gereğini ortaya koymaktadır.
Bu çalışma kapsamında çok kaynaklı verilerin işlenmesi, sürekli öğrenme işlevine sahip yapay zeka modellerinin entegre edildiği yeni sınıflama metodolojileri, görsel ve video içeriklerin kurumsal nitelik standartlarına uygun biçimde, düzenli ve tutarlı bir biçimde değerlendirilmesini sağlayan yenilikçi bir dijital uygulama olarak kullanımınıza sunulmuştur. Kullanıcı geri bildirimlerinden, Türk Kültürü ve Türk Beden Dili bağlamında etkisinin hareketlerin de yorumlanabileceği bir yapay zeka modeli geliştirildi/geliştirilmektedir, bu suret ile analiz süreleri kısalırken, sınıflama ve içerik analizi nispeten standartlaşmıştır. Analizler sırasında, zararlı içerik tespiti yapılmış video dosyalarında sadece ilgili kısım (2 saniye öncesi, olay ve 2 saniye sonrası) görüntülenmekte, böylece uzmanlar, saatlerce eş zamanlı olarak işleyebilecekleri bir video dosyası ile birden fazla dosya ile eş zamanlı olarak işlemekte. Sistem, Python tabanlı arka uç yazılım ve en son derin öğrenme modelleri (CLIP ve YOLO dahil) üzerine inşa edilmiş bir analiz katmanına sahiptir. Yapay zeka kullanıcı arayüzü, sınırlı yapay zeka okuryazarlığına sahip personel düşünülerek tasarlanmış, otomatik etiketleme ve geri bildirim almaktan uzmanların önerileri onaylamasına, düzeltmesine veya reddetmesine olanak tanımaktadır. Bu veriler, modelin yeniden eğitimi için kullanılarak sistemin doğruluğunu ve tutarlılığını zamanla artırmaktadır. Sistem, bilirkişi veya uzmanların değerlendirme sürelerinde %70’e kadar tasarruf sağlamayı, içerik analizlerinde tutarlılık ve standardizasyon getirmeyi, çalışanların psikososyal yükünü azaltmayı ve değerlendirme süreçlerinin genel kalitesini artırmayı amaçlamaktadır.
TEZİN AMACI ve HEDEFLER
Bu çalışmanın amacı, kurumsal gereksinimlere göre ayarlanabilen, otomatik sistemlerle video ve görsel içeriklerdeki uygunsuz içeriklerin tespit edilmesini sağlayan, üretim ortamında güvenle kullanabilecek ve sürdürülebilir bir sistemin, geliştirilmesi, uygulanması ve etkinliğinin değerlendirilmesidir.
Bu çalışmanın başlangıç aşaması, içerik sınıflandırmasının doğruluğunu artırma amacıyla OpenCLIP prompt tabanlı sıfırdan öğreti tekniklerinin uygulanmasını ve eğitilebilir model başlıklarının (Özel Başlıklar) kullanılmasını, bağlamsal doğrulama ve yanlış pozitiflerin azaltılmasını, YOLO görüntü işleme modeli aracılığıyla sağlanırken, risk kategorileri (şiddet, yetişkin, istismar, silah, ilaç) için ince ayrıntılı puanların üretilmesi,  kullanıcı düzeltmelerinin sisteme anında entegrasyonunu, değerlendirme süreçlerinin optimizasyonunu, artımlı öğrenme yoluyla eğitim sürelerinin azaltılmasını, sistem bakım dönemlerinde kaybı azaltmak için geri dönüş sağlama yeteneği ve sistem sürdürülebilirliğini artırmak için sürümleme ve geri alma mekanizmalarının entegrasyonunu hedeflemiştir.
Bu hedeflere yönelik olarak, kurumsal olarak kullanılabilir bir uygulama geliştirilmiş ve başarıyla üretim ortamında dağıtılmıştır. Sistem, kullanılan çerçeveler, CLIP iş birlikleri ve kişi takiplerine dayalı olarak iş kuyruklarını yönetir, gereksiz hesaplamalardan kaçınır ve değerlendirme döngü süresini optimize eder. Hafif özelliklerle yapılan artımlı güncellemeler, eğitim sürelerini minimize eder ve sürümleme ile geri alma mekanizmaları performans kayıplarını azaltır. Kişi takibindeki otomatik etiketleme mekanizmaları, insan hatalarını minimize eder ve aynı video dosyasında aynı kişi için birden fazla yaş tahminini önler.
Uygulamanın Erişim Güvenliği ve verilerin gizliliği, uygulamanın kritik bileşenleridir. Yerel dağıtımlar ve tutma bileşenleri ile veri sahiplerinin kişisel verileri sistemden çıkmaktan korunur. Dosya yolu ve MIME türü kontrolleri kötü niyetli dosya yüklemelerine karşı koruma sağlar. Hız sınırlaması ve güvenlik başlıkları (CSP, HSTS) siber saldırılara karşı koruma sunar. Tüm bu bileşenler, kurumsal gereksinimlerin (personelin yapay zeka okuryazarlığı, sosyal koruma, sosyal hizmetler ve çocuk koruma yasaları) akademik yöntemlerle entegre edilmesine ve yüksek doğruluk, güvenilirlik ve sürdürülebilirlikle çalışmasına olanak tanır.
Tez kapsamında, örnek uygulama geliştirme kodları da verilmiştir. Uzun vadede, içerik sınıflandırma, güvenlik alanlarında ve bunların ötesinde yapılacak yeni araştırma ve uygulamalar için temel bir model oluşturmasına imkan tanıyacaktır. Bu noktada, transfer ve artımsal öğrenme yöntemleri, güven skorlama teknikleri ve ROC optimizasyonu gibi akademik yöntemlerin sisteme entegrasyonu, sistemin mevcut uygulamalar ve gelecekteki kurumsal projelerde bir referans model olarak kullanılması için bir sistem esnekliği ve sürdürülebilir bir model ilke olarak benimsenmiştir. Sistem özelliği, farklı içerik türleri, risk kategorileri, güvenlik ihtiyaçları ve bu içeriklerin farklı türleri için ileride uyarlanabilir olmasını sağlamak, başlangıç hedefleri arasında bulunmaktadır.
KAPSAM ve KATKILAR
Çalışma, Python tabanlı bir arka uç mimarisinin uçtan uca tasarımını ve uygulanmasını içermektedir. Sistem, OpenCLIP, YOLO ve InsightFace bileşenlerinin entegrasyonu kullanılarak uygulanmıştır. Socket.IO çerçevesi kullanarak, bu bileşenler gerçek zamanlı ilerleme takibi ve sonuçların canlı akışını sağlar. Sonuç olarak, sistem, düşük gecikme süresi ve yüksek doğruluk analizi ile gerçek zamanlı kullanıcı geri bildirimi sağlayan bir üretim kalitesinde çözüme dönüştürülmüştür. Akademik katkıların ana odak noktası, çoklu model güven puanlama, zayıf denetimli öğrenme, çoklu görev içerik ve yaş analizi, kimlik sürekliliği video işleme ve ROC tabanlı güven eşik optimizasyonunu içermektedir. Sistem için önerilen çoklu model güven puanlama, CLIP'in anlamsal doğrulama çıktısını Buffalo-L ve yaş tahmini başlık tahminleri ile birleştirerek zayıf denetimli akışlardan yüksek kaliteli alt küme seçiminde kolaylık sağlar ve akışa yenilikçi bir katkıdır. Bu yaklaşım, zayıf denetimli öğrenme içeren sistemlere, literatürde bulunan güvenli sınıflandırma ve DivideMix (Northcutt et al., 2021; Li et al., 2020) gibi sağlam eğitim yöntemlerinin pratik mühendislik uyarlaması olarak hizmet eder. Bu, sistemin düşük güvenli eğitim örneklerinin dahil edilmesinin yol açabileceği potansiyel performans düşüşünü en aza indirmesine yardımcı olur.
İçerik analizi ve yaş tahmini, eşzamanlı olarak ilerledi ve bu kombinasyonu çalışmaya entegre etti. Bu entegrasyon, literatürde yalnızca birkaç çalışmada tartışılmakta olup, riskli içerikte 18 yaş altındaki bireylerin görünürlüğünün belirlenmesine yönelik yeni bir sosyal koruma odak noktası sunmaktadır. Bu çerçeve, çoklu görev öğrenme paradigmaları bağlamında içerik sınıflandırması ve yaş tahminini birleştirilmiş bir optimizasyon sürecinde entegre etmektedir. Bu, kaynak paylaşımını ve genel model verimliliğini artırmaktadır. 
Kişi izleme modülü, kimlik sürekliliği sistemi oluşturan DeepSORT algoritmasının PersonTrackerManager bileşeniyle güçlendirilmiştir. Bu, bir video akışındaki aynı kişiye ait karelerin sistematik olarak bağlanmasını sağlamakta ve yanlış pozitif olasılığını azaltmak için risk puanlarının konsolide edilmesini sağlamaktadır. Bu yaklaşım, kimlik sürekliliği ile videonun işleme maliyetini dengeleyen bir teknikleri literatüre katkıda sağlamaktadır. ROC eğrisi analiziyle optimize edilen CLIP modelinin güven eşik değeri (PSEUDO_LABEL_RECORD_CLIP_THRESHOLD=0.75) kesinlik ve hatırlama dengesini sağlamış ve kalite odaklı etiketlemenin miktar odaklı etiketlemeden üstün olduğunu kanıtlamıştır. Bu bulgu, koruyucu ölçümlerin standart ayarlarında hassas etik alanlardaki (örn. çocuk koruma ve içerik filtreleme) doğruluk ve güven dengesine önemli bir referans oluşturmaktadır.
Uygulamaya yönelik katkılar, kurumsal gereksinimlerle birleştirilen sistemin akademik bulguları üzerine inşa edilmiştir. On-premises dağıtım yapısı ve sürümleme/rollback mekanizmaları, kurum içi veri gizliliği, kesinti süresi minimizasyonu ve operasyonel risklerin kurumsal ölçekte yönetimini sağlamaktadır. Bu nedenle, sistem bulut tabanlı çözümlerden bağımsız olarak, regülasyon uyumlu ve kurum içi (self-hosted/on premises) bir yapıya sahiptir. Otomatik etiketleme modülü ve kullanıcı geri bildirim döngüsü, özellikle yapay zekâ okur yazarlığı düşük kullanıcı gruplarının bulunduğu ortamlarda, manuel iş yükünü azaltmakta ve etiketleme tutarlılığını artırmaktadır. Ayrıca, Windows geliştirme ortamı/kapsayıcı ve güvenlik odaklı orta katman ile modern yazılım mühendisliği ilkeleri ile entegre edilmiş bir mimari sunmaktadır. Overlay mekanizması, Türkçe karakter desteği ve erişilebilirlik odaklı arayüz düzenlemeleri kullanıcı deneyimini iyileştirirken; 18 yaş altı bireylere yönelik özel uyarı sistemleri sosyal koruma gereksinimlerini karşılamak üzere  geliştirilmiştir. Çoklu dosya yükleme desteği ile tek dosya-tek iş prensibi ve riskli kare çevresi kırpma (frame cropping) yaklaşımı büyük ölçekli taşınabilir medya akışlarının verimli biçimde işlenmesini sağlamaktadır. Tüm bu nedenlerle, çalışma güven skorlama, zayıf gözetimli veri seçimi, kimlik sürekliliği, sürdürülebilir model güncelleme ve güvenli veri işleme alanlarında tek bir akademik ve pratik uygulama olarak bütünleşik bir çözümdür.
Bu bağlamda, sistem, içeriğin güvenliği alanında akademik ilkeleri kurumsal uygulamalarla birleştirerek, literatürde önerilen yöntemleri üretim ortamına uygulamakta ve yeniden kullanılabilir bir referans modeli sağlamaktadır.
PROJE GELİŞTİRME SÜRECİ ve ZAMAN ÇİZELGESİ
Projenin başlatılmasında ihtiyaç analizi evresi kritik ve uzun süreli bir faz olarak gerçekleşmiştir. Kurum içi paydaşlarla yapılan görüşmelerin gereksinim toplama süreçlerine olumlu olarak yanıt verilmesi, kişisel verilerin internet veya bulut ortamına çıkmaması gereksinimlerinin sıralıda en üst sıralarda yer alması, sistemin tamamen on-premises olarak kurgulanması gerekliliğini ortaya koymuştur. Bununla birlikte, içerik akışlarının çoğunlukla yüksek kapasiteli taşınabilir medyalardan (harici diskler, USB) topluca sağlanması, çoklu dosya yükleme arayüze erişim tasarlanırken. Ayrıca, büyük boyutlu medya dosyalarının analizi esnasında kaynakların uzun süre bekletilmesi, iş akışı verimliliği açısından tek dosya–tek iş kuralı sistemi getirmek zorunluluğuna, kuyruk kontrolü ve iptal sistemlerinin sistem mimarisine kazandırılmasına sebep olmuştur. Personelin yapay zekâ okuryazarlığı seviyesinin düşük olması, otomatik etiketleme sisteminin gerekliliğini artırırken, kullanıcı geri bildirim arayüzünün sade ve anlaşılır olması tasarım prensibi olarak kabul edilmiştir.
Tasarım aşamasında, REST ve WebSocket arayüzleri için şemalar ayrıntılı bir şekilde hazırlandı; güvenlik önlemleri (MIME doğrulama, dosya yolu güvenliği, oran sınırlama) ve performans kriterleri (kuvvet tabanlı işleme, model önbellekleme) mimaride alınan kararlarda merkezi bir rol oynadı. Geliştirme aşamasında, Flask/SQLAlchemy/Socket.IO tabanlı arka uç sistemleri OpenCLIP, YOLO ve InsightFace bileşenleri ile entegre edildi. Test aşaması kapsamlıydı ve birim testi, entegrasyon testi ve kullanıcı kabul testi dahil olmak üzere sistemin teknik doğruluğu ve kullanıcı deneyiminin değerlendirildiği süreçlerden oluşuyordu. Bakım ve sürdürülebilirlik aşaması, versiyonlama ve geri alma mekanizmaları, periyodik temizlik görevleri ve günlük izleme yoluyla gerçekleştirildi; bu, sistemin uzun vadeli stabilitesini ve güvenilirliğini üretim ortamlarında sağlamayı ve operasyonel ortamlardaki güvenilirliğinin korunmasını amaçlıyordu.
Projenin geliştirilmesi yaklaşık 12 aylık bir süreçte gerçekleştirilmiştir. İlk üç ay, ihtiyaç analizi ve tasarım evresine ayrılmış; paydaş toplantıları, güvenlik gereksinimlerinin belirlenmesi ve mimari kararlar bu süreçte tamamlanmıştır. Dört-sekiz aylık dönem geliştirme evresini kapsamış; Flask arka uç, SQLAlchemy ORM, Socket.IO entegrasyonu, OpenCLIP/YOLO/InsightFace model entegrasyonları, güvenlik ara bileşeni, kuyruk servisi ve kullanıcı arayüzü bu aşamada tamamlanmıştır. Dokuz-on birinci aylar test ve iyileştirme evresine ayrılmış; birim, entegrasyon ve kullanıcı kabul testleri yürütülmüş, performans darboğazları tespit edilip optimize edilmiş, sürümleme/rollback mekanizmaları eklenmiştir. On ikinci ay, dokümantasyon, bakım prosedürlerinin yazılması ve üretim dağıtım hazırlıklarını kapsamıştır. Bu zaman çizelgesi, kurumsal gereksinimler ve kaynak kısıtları göz önüne alınarak planlanmış; çevik (agile) ilkelerle küçük artımlarla ilerleme ve sürekli geri bildirim döngüsü benimsenmiştir. Her sprint sonunda paydaşlara demo sunulmuş, geri bildirimler bir sonraki sprint planına dahil edilmiştir. Bu yaklaşım, gereksinim değişikliklerine hızlı uyumu ve son kullanıcı memnuniyetini artırmıştır.
Şekil 1.2. Proje Takvimi

BÖLÜM 2 GENEL BİLGİLER VE LİTERATÜR
2.1. BİLGİSAYARLI GÖRÜ ve İÇERİK ANALİZİ TEMELLERİ
Görsel içerik analizinin amacı, bir görüntü veya video karesinin anlamlı bileşenlerinin sayısal temsilini içermekte ve bu temsillerin sınıflandırılması, tespiti veya yorumlanması gibi sonraki görevleri kapsamaktadır. Bu sürecin merkezinde, bir giriş görüntüsünün özelliklerinin veya derin temsillerinin öğrenimi yer almaktadır. Özelliklerin çıkarılması, ham piksellerin yüksek boyutlu, ancak anlamlı, vektör alanlarına dönüştürülmesini sağlar, böylece makine öğrenimi modelleri kavramları soyutlayabilir ve ayırt edebilir. Denetimli öğrenme senaryolarında, bu temsiller doğrudan insan etiketleri ile hizalanırken, zayıf denetimli ve yarı denetimli ortamlarda veri kalitesi ile güvenilirlik ve güven düzeyi kritik öneme sahiptir. Bu ortamlarda, etiket gürültüsü nedeniyle, modelin genelleme yeteneği önemli ölçüde zayıflayabilir. Sonuç olarak, puan güvenilirlik değerlendirmesi, belirsizlik modelleme ve veri temizleme mekanizmalarının kullanılması sağlanmalıdır.
Özellik normalizasyonu, derin öğrenme modellerinin üretim ortamlarında uygulanabilirliğini artıran temel aşamalardan biridir. Batch normalization, layer normalization ve L2 normalizasyonu gibi yöntemler; eğitim sürecinde istikrarlı gradyan akışı sağlamaya, temsil vektörlerinin ölçek tutarlılığını korumaya ve modelin genel öğrenme dinamiklerini dengelemeye yardımcı olur. Ancak, yaş grupları veya risk kategorileri gibi dağılımı dengesiz veri kümelerinde, modelin yanlılık (bias) üretme olasılığı artar. Bu tür durumlarda, weighted sampling, focal loss ve yeniden örnekleme (re-sampling) teknikleri sınıf dengesizliğini azaltmak için kullanılır. Öte yandan, model kalibrasyonu, eğitimli modellerin olasılık tahminlerinin gerçek olasılıklarla uyumlu olmasını sağlayarak, hatalı güven düzeylerinin yayılmasını önler. Ayrıca, hataların bir kısmı sistematik (epistemik belirsizlik), bir kısmı ise rastlantısal (aleatorik belirsizlik) niteliktedir. Bu ayrım, veri kaynaklı ve model kaynaklı belirsizliklerin analiz edilmesine olanak tanır ve tahmin güvenilirliğinin değerlendirilmesinde önemli bir rol oynar. ******
Etik boyutta, adalet (fairness) ve gizlilik (privacy) ilkeleri görsel veri analizinin temel tasarım ilkeleri arasında yer almaktadır. Fairness kavramı, modelin farklı demografik gruplar arasında tarafsız karar verebilmesini ölçen metrikleri (demografik parite, eşit fırsat, equalized odds vb.) içerir. Özellikle yaş, cinsiyet ve etnik köken değişkenleri içeren veri kümelerinde modelin ayrımcı davranış göstermemesi, sosyal açıdan kritik bir gerekliliktir. Gizlilik tarafında, differential privacy, bireylerin verilerinin istatistiksel anonimlik düzeyini koruyarak model eğitimi yapılmasını mümkün kılar. Federated learning (dağıtık öğrenme) yaklaşımı ise verinin merkezi sunuculara aktarılmadan, cihazlar üzerinde yerel olarak eğitilmesiyle veri gizliliği ve regülasyon uyumluluğu (ör. KVKK, GDPR) sağlar.
Görsel temsillerin öğrenilmesinde Konvolüsyonel Sinir Ağları (CNN) uzun yıllar temel yaklaşım olarak kullanılmıştır. CNN mimarileri, görüntülerdeki yerel desenleri (kenar, doku, renk geçişi) düşük seviyeden yüksek seviyeye ilerleyen hiyerarşik yapılar hâlinde öğrenir. ResNet mimarisi (He ve diğerleri, 2016), “residual connection” yapısıyla derin ağlarda gradyan sönümleme sorununu aşmış ve yüzlerce katman içeren derin ağların eğitilmesini mümkün kılmıştır. ResNet-50, ResNet-101 ve ResNet-152 varyantları, parametre sayısı ve derinlik açısından farklı uygulamalara uyarlanabilir. CNN tabanlı yaklaşımlar, nesne tespiti, yüz tanıma ve sahne analizi gibi görevlerde yüksek başarı göstermektedir.
Son yıllarda Transformer tabanlı mimariler, dikkat mekanizması (self-attention) sayesinde görsel görevlerde CNN’lere rakip veya üstün performans sergilemiştir. Vision Transformer (ViT) modeli (Dosovitskiy ve diğerleri, 2021), görüntüleri küçük yamalara (patch) bölerek her bir yamayı birer token olarak işler ve BERT benzeri mimariyle global bağlamı öğrenir. DETR (DEtection TRansformer) (Carion ve diğerleri, 2020) bu yapıyı nesne tespitine uyarlayarak, anchor-free ve set prediction mekanizmaları ile bounding box ve sınıf tahminini birlikte gerçekleştirir. Transformer tabanlı yöntemler, özellikle çoklu nesne sahnelerinde bağlamsal ilişkileri daha doğru modelleyebilme avantajı sunar.
Veri artırma (data augmentation) stratejileri, sınırlı veri kümelerinde modelin genelleme yeteneğini artırmak için kullanılmaktadır. Basit geometrik dönüşümler (döndürme, yansıtma, ölçekleme) ile başlayan bu yaklaşım, son dönemde mixup, cutmix ve RandAugment gibi ileri düzey yöntemlerle zenginleştirilmiştir (Shorten ve Khoshgoftaar, 2019). Bu teknikler, yapay olarak çeşitlilik yaratırken aşırı öğrenmeyi (overfitting) azaltır.
Nesne tespiti (object detection) ve görsel segmentasyon (image segmentation) görevleri, içerik analizi açısından kritik rol oynamaktadır. Nesne tespitinde sahnedeki varlıklar, sınırlayıcı kutular (bounding box: x, y, w, h) ve sınıf etiketleriyle birlikte belirlenir. YOLO (Redmon ve Farhadi, 2018) tek-aşamalı bir grid tabanlı yaklaşım kullanırken, Faster R-CNN (Ren ve diğerleri, 2015) iki-aşamalı bir yapı (region proposal + classification) benimser; DETR ise transformer tabanlı mimarisiyle farklı bir paradigma sunar. Segmentasyon görevinde ise her piksel bir sınıfa atanır (semantik segmentasyon) veya her nesne örneği ayrı maskelenir (instance segmentasyon) (Long ve diğerleri, 2015).
Bu temel yaklaşımlar, görsel içerik analizi kapsamında risk kategorilerinin tespiti, yaş tahmini ve kimlik takibi gibi çoklu görevlerin bir arada yürütülmesini mümkün kılmaktadır. Özellikle yaş tahmini görevinde yüz ROI (Region of Interest) çıkarımı ile regresyon tabanlı modellerin bütünleştirilmesi, sahne içindeki bireylerin bağlamsal olarak değerlendirilmesine olanak sağlamaktadır. Böylece, derin temsil öğrenimi, etik/gizlilik bilinci ve çoklu görevli öğrenme ilkeleri bir araya gelerek hem akademik hem de kurumsal gereksinimlere uyumlu bir görsel analiz çerçevesi ortaya koymaktadır.
2.2. TRANSFER/ARTIMSAL ÖĞRENME YAKLAŞIMLARI
Görsel içeriklerin analizi yalnızca piksel düzeyinde örüntü tanımayı değil, aynı zamanda bu örüntülerin dilsel ve anlamsal bağlamla ilişkilendirilmesini de gerektirir. Bu doğrultuda geliştirilen CLIP (Contrastive Language–Image Pre-training) modeli, metin ve görüntü temsillerini ortak bir uzayda eşleştirerek görsel anlayışın dilsel yönünü modellemektedir. CLIP, 400 milyon metin–görüntü çifti üzerinde kontrastif öğrenme yöntemiyle eğitilmiştir ve bir görüntü ile onu tanımlayan metin arasındaki benzerliği en üst düzeye çıkarmayı amaçlar (Radford ve diğerleri, 2021). Böylece model, önceden tanımlı sınıf etiketlerine gerek duymadan yalnızca metin istemleri (prompts) aracılığıyla sıfır-örnek (zero-shot) sınıflandırma yapabilmektedir. Bu özellik, içerik sınıflarının sıklıkla değiştiği ortamlarda modelin yeniden eğitilmeden yeni kavramlara genelleme yapabilmesini sağlar. CLIP’in açık kaynak sürümü olan OpenCLIP, LAION-5B gibi geniş ölçekli veri kümeleri üzerinde eğitilmiş varyantlarıyla akademik araştırmalardan kurumsal uygulamalara kadar farklı bağlamlarda kullanılabilir hâle gelmiştir (Schuhmann ve diğerleri, 2022).
CLIP’in temelinde yer alan Vision Transformer (ViT) mimarisi, görüntüleri küçük yamalara (patch) ayırarak her bir yamayı birer girdi token’ı olarak işler ve dikkat mekanizması (self-attention) aracılığıyla global bağlam ilişkilerini öğrenir. Bu yapı, konvolüsyonel ağların yerel desenlere odaklanan doğasından farklı olarak, sahne içindeki nesneler arasındaki bağlamsal ilişkileri yakalayabilme yeteneği kazandırır (Dosovitskiy ve diğerleri, 2021). Böylelikle CLIP, yalnızca sınıflandırma görevlerinde değil, aynı zamanda anlamsal doğrulama, risk kategorisi tanıma ve bağlam farkındalığı gerektiren içerik analizlerinde de yüksek doğruluk düzeyi sunar.
Nesne ve kişi tespiti alanında YOLO (You Only Look Once) mimarisi, hız ve doğruluk dengesi açısından öne çıkan tek-aşamalı bir yaklaşımdır. YOLO, girdi görüntüsünü grid tabanlı bir yapıya bölerek aynı anda hem nesne sınıflarını hem de konumlarını (bounding box koordinatlarını) tahmin eder (Redmon ve Farhadi, 2018). Modelin son sürümleri olan YOLOv7 ve YOLOv8, anchor-free yapı, CSP blokları ve “bag-of-freebies” teknikleriyle parametre verimliliğini artırmış, küçük nesnelerin tespitinde ve düşük ışık koşullarında doğruluk iyileştirmeleri sağlamıştır (Wang ve diğerleri, 2023). YOLO’nun bu uzamsal doğrulama kapasitesi, CLIP’in anlamsal sınıflandırma kabiliyetiyle birleştirildiğinde, sistem hem ne tür bir içeriğin hem de içerikteki nesnelerin nerede bulunduğunun eşzamanlı olarak belirlenmesini mümkün kılar. Böyle bir birleşim, özellikle şiddet, silah, taciz veya yetişkin temalı içerik gibi yüksek risk kategorilerinde yanlış pozitif oranlarını azaltarak kurumsal doğrulama süreçlerinde güvenilirliği artırır.
InsightFace mimarisi, yüz tanıma, yaş ve cinsiyet tahmini gibi yüz odaklı görevlerde endüstri standardı hâline gelmiş bir çözümdür. Sistem, RetinaFace bileşeni aracılığıyla yüz bölgesini (Region of Interest) tespit eder ve ArcFace kayıp fonksiyonunu kullanarak 512-boyutlu bir yüz temsili (embedding) üretir (Deng ve diğerleri, 2019a; Deng ve diğerleri, 2019b). ArcFace, açısal marjinal yumuşatma (angular margin softmax) yöntemiyle benzer yüzlerin temsil uzayında daha sıkı kümelenmesini, farklı bireylerin ise belirgin biçimde ayrılmasını sağlar. InsightFace ayrıca yaş ve cinsiyet başlıkları (Custom Age Head, Gender Head) aracılığıyla demografik tahmin yapabilmekte, bu da özellikle 18 yaş altı bireylerin riskli içeriklerde tespiti gibi sosyal koruma odaklı uygulamalarda önemli bir avantaj sunmaktadır. Böylece CLIP’in anlamsal bağlam çözümlemesi, YOLO’nun konumsal tespiti ve InsightFace’in kişi düzeyindeki analizi birlikte kullanılarak, çok-modelli (multi-modal) ve bağlamsal olarak tutarlı bir değerlendirme mekanizması oluşturulmaktadır.
Model geliştirme sürecinde transfer öğrenme ve artımsal öğrenme (incremental/continual learning) yaklaşımları, sistemin hem verimliliğini hem de sürdürülebilirliğini belirleyen temel bileşenlerdir. Transfer öğrenme, önceden geniş veri kümeleri üzerinde eğitilmiş modellerin bilgi birikimini yeni görev alanlarına aktarmayı amaçlar. Bu sayede, sınırlı etiketli veriyle çalışan sistemler dahi yüksek performans elde edebilir. Özellikle ImageNet üzerinde eğitilmiş ResNet veya ViT modelleri, görsel özniteliklerin genelleştirilebilir temsillerini sağlayarak eğitim süresini önemli ölçüde kısaltır (Pan ve Yang, 2010; He ve diğerleri, 2016). Fine-tuning sürecinde, yalnızca son katmanların yeniden eğitilmesi veya tüm ağın optimize edilmesi kararı, kaynak ve hedef alanlar arasındaki farkın büyüklüğüne (domain gap) bağlı olarak belirlenir (Howard ve Ruder, 2018).
Artımsal öğrenme ise modelin zaman içerisinde yeni verilerle güncellenirken önceki bilgilerini unutmadan öğrenmesini sağlar. Dinamik veri akışlarının bulunduğu sistemlerde, bu yaklaşım modelin sürekli yeniden eğitilme ihtiyacını ortadan kaldırarak öğrenmenin sürekliliğini destekler. Bu süreçte karşılaşılan en temel zorluk, modelin yeni bilgileri öğrenirken geçmiş bilgileri unutması, yani katastrofik unutma (catastrophic forgetting) problemidir. Bu sorun, literatürde üç temel stratejik yönelim çerçevesinde ele alınmaktadır. Düzenleme-tabanlı yaklaşımlar (örneğin Elastic Weight Consolidation), modelin belirli parametrelerinin önceki görevlerdeki önemine göre değişimini sınırlandırarak unutmayı azaltır (Kirkpatrick ve diğerleri, 2017). Tekrar-tabanlı yaklaşımlar, önceki görevlerden seçilmiş örnekleri veya temsilleri bellekte tutarak modelin bu verilerle birlikte yeniden eğitilmesini sağlar ve böylece bilgi bütünlüğünü korur (Rebuffi ve diğerleri, 2017). Mimari-tabanlı yöntemlerde ise model, her yeni görev için yeni alt-ağlar veya parametre blokları ekleyerek bilgiyi modüler biçimde genişletir (Li ve Hoiem, 2016). Bu üç yönelim birlikte kullanıldığında, sistem hem istikrar hem genişletilebilirlik hem de geçmiş bilgiye bağlılık bakımından dengeli bir öğrenme çerçevesi kazanır.
Kurumsal ortamda bu süreç sürümleme (versioning) ve geri dönüş (rollback) mekanizmalarıyla bütünleştirilmektedir. Her eğitim döngüsü, hiperparametre ayarları, veri versiyonu ve performans metrikleriyle birlikte metadata olarak kaydedilmekte; performans düşüşü veya veri tutarsızlığı tespit edildiğinde sistem otomatik olarak önceki sürüme dönmektedir. Böylece yalnızca modelin doğruluğu değil, aynı zamanda operasyonel sürdürülebilirliği ve güvenilirliği de sağlanmaktadır.
Sonuç olarak, CLIP, YOLO, InsightFace ve transfer/artımsal öğrenme yaklaşımlarının bütünleşik biçimde kullanımı, metinsel, görsel ve demografik bağlamı eşzamanlı olarak işleyen, kendini sürekli güncelleyebilen ve kurumsal güvenlik gereksinimlerine uyumlu bir yapay zekâ altyapısı oluşturur. Bu yapı, akademik açıdan çok-modelli temsillerin öğrenilmesine, uygulama düzeyinde ise sosyal koruma ve içerik güvenliği alanlarında yeni nesil çözümlerin geliştirilmesine katkı sağlamaktadır.
2.3. VERİ KALİTESİ ve GÜVEN SKORLAMA
Gerçek dünya verilerinde gürültü, etiketleme hataları ve dağılım kaymaları kaçınılmaz biçimde ortaya çıkmakta; bu durum, makine öğrenmesi modellerinin genelleme yeteneğini düşürmekte ve sistematik önyargıların oluşumuna zemin hazırlamaktadır. Veri gürültüsünün temel kaynakları arasında sensör bozulmaları, insan etiketçiler arasındaki yorum farklılıkları, dikkat dağınıklığı sonucu oluşan etiketleme hataları, otomatik veri toplama süreçlerinden (örneğin web scraping veya OCR hataları) kaynaklanan etiket sapmaları ve zamanla değişen veri dağılımları (domain shift) yer almaktadır. Bu tür bozulmalar, modelin güvenilirliğini azaltmakla kalmaz; aynı zamanda üretim ortamına taşındığında yanlış kararların alınmasına da neden olabilir.
Bu çalışmada, veri kalitesinin artırılması amacıyla çok-modelli uzlaşı sinyali ve CLIP tabanlı anlamsal doğrulama birlikte kullanılmaktadır. Farklı modellerin (örneğin CLIP, YOLO, InsightFace) aynı örnek için benzer tahminler üretmesi, örneğin yüksek güvenilirlik taşıdığını göstermektedir. Buna karşılık, modeller arasında önemli tahmin farkları oluştuğunda, bu durum verinin belirsiz veya hatalı olduğunu işaret etmektedir. Böylece model uyuşmazlığı (model disagreement) bir güvenlik göstergesi olarak işlev görmekte, zayıf veya yanlış etiketlenmiş örneklerin eğitimden elenmesine olanak tanımaktadır. CLIP tabanlı sistemlerde, pozitif ve negatif istemlerle elde edilen benzerlik skorları arasındaki fark (Δ = pos_max − neg_max) normalize edilerek 0–1 aralύπύnda bir gόven skoru oluώturulmaktadύr. CLIP benzerlik skorlarύ doπrudan 0–100 aralύπύnda όretildiπinden, farkύn sigmoid dφnόώόmόyle olasύlύk biηimine getirilmesi gόvenin sayύsallaώtύrύlmasύnύ saπlamaktadύr.
Modern derin aπlarύn bir diπer φnemli sorunu olasύlύk kalibrasyonudur. Literatόrdeki birηok ηalύώma, aπlarύn sύklύkla “aώύrύ gόvenli” (overconfident) tahminler όrettiπini, φrneπin tahmin olasύlύπύ %90 olan bir φrneπin gerηekte yalnύzca %70 oranύnda doπru ηύktύπύnύ gφstermiώtir (Guo ve diπerleri, 2017). Bu nedenle, modelin ηύktύ olasύlύklarύnύn doπru ώekilde kalibre edilmesi, sistem gόvenilirliπi aηύsύndan kritik φneme sahiptir. En yaygύn yφntemlerden sύcaklύk φlηeklendirmesi (temperature scaling), softmax fonksiyonuna sύcaklύk parametresi (T) ekleyerek olasύlύk daπύlύmύnύ yumuώatύr; T>1 deπerleri daha dόώόk gόvenli, T<1 deπerleri ise daha keskin olasύlύklar όretir. Alternatif bir yφntem olan Platt φlηeklendirmesi, doπrulama kόmesi όzerinde lojistik regresyon eπitilerek kalibrasyon parametrelerini φπrenir (Lin ve diπerleri, 2007).
Eώik deπeri seηimi, kalibrasyon sόrecinin ayrύlmaz bir parηasύdύr. Bu ηalύώma kapsamύnda eώik optimizasyonu, ROC (Receiver Operating Characteristic) ve PR (Precision–Recall) eπrileri όzerinden gerηekleώtirilmiώtir. ROC eπrisi, gerηek pozitif oranύ (TPR = TP/(TP+FN)) ile yanlύώ pozitif oranύ (FPR = FP/(FP+TN)) arasύndaki iliώkiyi gφsterirken; PR eπrisi, hassasiyet (precision = TP/(TP+FP)) ve geri ηaπύrma (recall = TP/(TP+FN)) dengesini sunar (Davis ve Goadrich, 2006). Φzellikle dengesiz veri kόmelerinde (φrneπin pozitif φrneklerin %5’ten az olduπu senaryolar), ROC eπrisi yanύltύcύ sonuηlar verebilir; bu nedenle PR eπrisi daha bilgilendirici bir φlηόt olarak tercih edilmiώtir. Ηok dόώόk eώik deπerleri (φrneπin 0.3), sisteme gόrόltόlό verilerin dahil olmasύna ve yanlύώ pozitif oranύnύn artmasύna yol aηarken; aώύrύ yόksek eώikler (φrneπin 0.95) pozitif φrneklerin elenmesine, dolayύsύyla veri ηeώitliliπinin azalmasύna neden olmaktadύr. Bu denge noktasύnύ belirlemek amacύyla eπri altύ alan (AUC) analizi yapύlmύώ ve optimum gόven eώiπi τ=0.75 olarak deneysel biηimde belirlenmiώtir.
Sistemdeki orta gόven aralύπύ (0.5–0.75) φrnekleri, otomatik etiketleme yerine insan-dφngόde (human-in-the-loop) bir gφzden geηirme kuyruπuna yφnlendirilmektedir. Bu strateji, tam otomatikleώtirilmiώ sistemlerin neden olabileceπi φnyargύ birikimini ve hatalύ etiketlerin eπitim verisine girmesini engellerken, insan uzmanlύπύnύn yalnύzca belirsiz durumlarda devreye girmesini saπlayarak operasyonel verimliliπi artύrmaktadύr.
Model gόveninin analitik olarak deπerlendirilebilmesi iηin belirsizlik tahmini (uncertainty estimation) de sisteme entegre edilmiώtir. Belirsizlik, genellikle iki temel bileώene ayrύlmaktadύr: epistemik belirsizlik, modelin bilgi eksikliπinden veya veri azlύπύndan kaynaklanmakta; aleatorik belirsizlik ise verinin doπasύnda bulunan rastlantύsal gόrόltό ve etiket hatalarύndan doπmaktadύr. Epistemik belirsizlik, modelin yeni veya nadir φrneklerle karώύlaώtύπύnda yaώadύπύ kararsύzlύπύ temsil ederken; aleatorik belirsizlik, girdi sinyalinin iηsel tutarsύzlύklarύnύ yansύtύr. Bayesian yaklaώύmlar, φzellikle Monte Carlo Dropout tekniπiyle (MC Dropout), birden fazla ileri geηiώ (forward pass) sonucunda tahmin varyansύnύ φlηerek belirsizlik miktarύnύ nicelleώtirir (Hendrycks ve Gimpel, 2017). Ansambl yφntemleri (ensemble methods) ise farklύ modellerin tahminlerini bir araya getirir; dόώόk varyans durumunda uzlaώύ yόksek, dolayύsύyla belirsizlik dόώόktόr.
Veri kalitesinin sayύsal olarak deπerlendirilmesi iηin ηeώitli φlηόtler kullanύlmaktadύr. Etiket tutarlύlύπύ, aynύ φrneπe farklύ etiketηilerin ne φlηόde benzer kararlar verdiπini φlηer; φzellik ηeώitliliπi, veri kόmesinin farklύ demografik veya baπlamsal gruplarύ kapsayύp kapsamadύπύnύ deπerlendirir. Ayrύca demografik denge (yaώ, cinsiyet, etnik kφken daπύlύmύ) ve teknik kalite φlηόtleri (φrneπin ηφzόnόrlόk >112Χ112, bulanύklύk φlηόtό Laplacian varyansύ >100, sinyal-gόrόltό oranύ >20 dB) veri kόmesinin gόvenilirlik dόzeyini belirleyen ek faktφrlerdir. Bu gφstergelerin her biri, eπitim sόrecinde model baώarύmύnύ farklύ yφnlerden etkilemekte; dolayύsύyla veri kalitesi deπerlendirmesi yalnύzca etiket doπruluπuna deπil, aynύ zamanda ηeώitlilik, denge ve teknik bόtόnlόπe de dayandύrύlmaktadύr.
Veri kόmelerinde etiket hatalarύ, daπύlύm kaymalarύ ve sistematik φnyargύlar, model φπrenme etkinliπini dόώόrmekte ve genelleme kapasitesini sύnύrlamaktadύr. Bu baπlamda, literatόrde φnerilen yφntemler; etiket gόrόltόsόnόn modellenmesi, robust eπitim ve seηici φrnek kullanύmύ eksenleri όzerinden geliώmiώtir. Confident Learning yaklaώύmύ, sύnύf koώullu gόrόltό matrisini istatistiksel olarak modelleyerek hatalύ φrnekleri tespit etmekte ve veri temizliπi saπlamaktadύr (Northcutt ve diπerleri, 2021). Gόrόltόlό etiketli veri ile eπitimde, erken φπrenme etkisi (temiz φrneklerin φncelikli φπrenilmesi) ve φrnek seηimi/aπύrlύklandύrma stratejileri performansύ artύrmaktadύr (Chen ve diπerleri, 2019).
Bu tezde, benzer ilke φrnek-bazlύ aπύrlύklύ MSE kaybύ ile uygulanmύώ; yόksek CLIP gόvenli φrnekler eπitime daha fazla katkύ saπlamaktadύr. Ayrύca, model tahmin uyuώmazlύπύ (Buffalo-L vs. Custom Age Head) dόώόk gόvenli φrnekleri iώaret etmekte ve ηapraz testler ile en gόvenilir φrnekler seηilmektedir (Yu ve diπerleri, 2019). CLIP kontrastif φn-eπitimi, doπal dil denetimi ile ortak metin-gφrόntό yerleώtirmesi φπrenerek anlamsal benzerliπi gόvenilir bir kalite gφstergesine dφnόώtόrmekte; istem-temelli deπerlendirme, yorumlanabilir ve kontrol edilebilir bir katman oluώturmaktadύr (Radford ve diπerleri, 2021; Khattak ve diπerleri, 2023).
Tez kapsamύnda, ηok-modelli uzlaώύ yaklaώύmύ (Buffalo-L ve Custom Head ηύktύlarύ) CLIP tabanlύ metin-temelli gόven skorlarύ ile birleώtirilmiώ ve zayύf gφzetimli akύώlardan nitelikli altkόmelerin seηimi saπlanmύώtύr. Bu yφntem, literatόrde φnerilen robust eπitim teknikleri ile gφrό-dil (vision-language) tabanlύ anlamsal deπerlendirmeyi bir araya getirerek hem doπruluk hem de veri gόvenliπi aηύsύndan gόηlό bir ηerηeve sunmaktadύr. Sonuη olarak, ηalύώma veri kalitesini artύrmak ve model gόvenini sistematik biηimde φlηmek amacύyla, ηok-modelli uzlaώύ, kalibrasyon temelli gόven skorlama, belirsizlik tahmini ve insan-dφngόde gφzden geηirme yaklaώύmlarύnύ bόtόnleώtiren bir yapύ ortaya koymaktadύr. Bu bόtόnleώik yaklaώύm, yalnύzca istatistiksel doπruluπu deπil, aynύ zamanda etik ve operasyonel gόvenilirliπi de gφzeten bόtόncόl bir veri yφnetim ηerηevesi olarak deπerlendirilmektedir.
2.4. UYGULAMA ODAKLI ÇALIŞMALAR ve BOŞLUK ANALİZİ
Mevcut literatür, büyük ölçüde Batı dillerine ve kültürel temsillerine odaklanmış veri kümeleri üzerine inşa edilmiştir. ImageNet, COCO, CelebA ve UTKFace gibi yaygın veri setleri, ağırlıklı olarak İngilizce etiketler ve Batı toplumlarına özgü demografik dağılımlar içermektedir. Bu durum, modellerin farklı kültürel bağlamlarda genelleme yapma kapasitesini sınırlamakta; özellikle Türkçe gibi düşük kaynaklı dillerde ve farklı toplumsal normlara sahip toplumlarda, içerik sınıflandırma performansının düşmesine yol açmaktadır. Türkçe bağlamda, toplumsal davranış kalıplarına özgü görsel göstergelerin örneğin yakın temas biçimleri, jest ve mimiklerin anlam farklılıkları, giyim ve mahremiyet normlarının sınıflandırma çıktıları üzerindeki etkisi, literatürde yeterince derinlemesine incelenmemiştir.
Benzer biçimde, içerik moderasyonu konusundaki çalışmalar da çoğunlukla İngilizce dilinde, Batı kültürü çerçevesinde yürütülmektedir. Nefret söylemi, şiddet veya yetişkin içerik tespiti gibi alanlarda kullanılan istem setleri (prompt templates) ve risk kategorileri, genellikle Batı kültürünün sosyal kodlarını yansıtmaktadır. Türkçe ve yerel kültürel bağlama özgü semantik varyantların, jestsel veya dilsel nüansların dikkate alınmaması, modellerin yanlış pozitif ve yanlış negatif oranlarını artırmakta; bu da içerik güvenliğini sağlama süreçlerinde ciddi doğruluk kayıplarına yol açmaktadır. Literatürde Türkçe içerik moderasyonu için özel olarak tasarlanmış istem setleri, bağlamsal filtreleme stratejileri veya yerelleştirilmiş etiketleme yönergeleri sınırlı düzeydedir. Özellikle Türkçe bağlamda jest ve mimik kullanımı, kişiler arası fiziksel mesafe, giyim-kuşam normları ve sosyal etkileşim biçimleri gibi kültürel göstergelerin görsel sınıflandırma performansına etkisi sistematik olarak ele alınmamıştır. Bu durum, büyük ölçüde mevcut veri kümelerinin Batı merkezli görsel temsillerle sınırlı olmasından kaynaklanmakta; bu da Türk kültürel bağlamında üretilen içeriklerin model tarafından yanlış veya eksik değerlendirilmesine yol açabilmektedir. Bu eksiklik, özellikle kamu kurumları veya sosyal koruma odaklı uygulamalarda, modellerin karar mekanizmalarının yerel normlarla uyumsuz sonuçlar üretmesine neden olabilmektedir.
Çok‑dilli ve çok‑kültürlü içeriklerde semantik belirsizlikler ve bağlam kaymaları daha belirgindir; istem tasarımında yerelleştirilmiş söz öbekleri ve kültürel imleçler tercih edilmelidir. Görsel sahnelerde aynı nesnenin farklı kültürel kabul düzeyleri (ör. kamusal alanda yakın temas) sınıflandırma kararını etkiler. Geliştirilen uygulama kullanıcı geri bildirimlerinden beslenerek modelin gelişmesi sağlanabilmektedir.
Öte yandan, akademik literatürde yöntemsel olarak güçlü birçok model önerilmesine karşın, üretim (production) aşamasına taşınabilir sistem mimarilerinin ayrıntılarına yeterince yer verilmemektedir. Sürümleme (versioning), geri alma (rollback), kuyruk yönetimi, iptal mekanizmaları, on-premises dağıtım, WebSocket tabanlı gerçek zamanlı bildirim sistemleri ve dosya yol politikaları gibi pratik mühendislik bileşenleri, genellikle deneysel aşamada göz ardı edilmekte; bu da araştırma bulgularının operasyonel sistemlere aktarılmasını güçleştirmektedir. Akademik prototiplerin çoğu, yüksek doğruluk oranları sunsa da, güvenlik, gizlilik, sürdürülebilirlik ve sistem kararlılığı açısından üretim ortamı gereksinimlerini karşılayamamaktadır.
Video analizinde kişi takibi (person tracking) genellikle kimlik sürekliliği (identity persistence) amacıyla kullanılmakta; DeepSORT ve benzeri algoritmalar, bounding box koordinatları ve embedding temsilleri aracılığıyla her bireye benzersiz bir kimlik atayarak nesne takibini sürdürmektedir (Wojke ve diğerleri, 2017). Ancak bu takip süreçlerinin içerik risk skorları ve yaş tahmini çıktılarıyla bütünleştirilmesine ilişkin sistematik bir çerçeve literatürde bulunmamaktadır. Bu eksiklik hem hesaplama verimliliği hem de semantik bütünlük açısından önemli bir sınırlılık oluşturmaktadır.
Bu tez kapsamında geliştirilen sistem, söz konusu boşluğu kapatmak amacıyla içerik analizi (OpenCLIP + YOLO), yaş tahmini (InsightFace) ve kişi takibi (DeepSORT + PersonTrackerManager) bileşenlerini tek bir video analiz hattında bütünleştirmiştir. Her birey için benzersiz bir kimlik (unique ID) üretilmiş, video boyunca kimlik sürekliliği korunmuş ve her kişi için en güvenilir kare seçilerek içerik risk skorları ile yaş bilgisi birlikte overlay katmanında sunulmuştur. Aynı bireyin farklı sahnelerde tekrar görünmesi durumunda önceki yaş tahmininin kimlik bazında yeniden kullanılması hem gereksiz hesaplama maliyetini azaltmış hem de tahmin kararlılığını artırmıştır. Uzun süreli video akışlarında kimlik kayıplarını önlemek için MAX_LOST_FRAMES ve TRACKING_RELIABILITY_THRESHOLD gibi parametrelerin dinamik biçimde ayarlanabilir olması, sistemin üretim ortamına uyarlanabilirliğini güçlendirmiştir.
Bu birleşik yaklaşım, içerik analizi ve yaş tahmininin bütünleşik olarak yürütülmesini sağlayarak sosyal koruma odaklı uygulamalar için yenilikçi bir çözüm ortaya koymaktadır. Böylece çalışma, literatürdeki ayrık yaklaşımların sınırlılıklarını aşarak hem teknik hem etik düzlemde yeni bir uygulama çerçevesi sunmaktadır.
Mevcut literatürde içerik analizi ve yaş tahmini genellikle birbirinden bağımsız araştırma alanları olarak ele alınmaktadır. İçerik moderasyonu çalışmaları ağırlıklı olarak şiddet, istismar veya uygunsuz materyal gibi risk kategorilerinin tespitine odaklanırken, yaş bilgisini değerlendirme sürecine dâhil etmemektedir. Buna karşılık, yaş tahmini literatürü yüz tabanlı regresyon ve sınıflandırma yöntemleriyle ilgilenmekte; ancak içerik bağlamını ya da sahne düzeyindeki risk skorlarını hesaba katmamaktadır. Bu ayrışma, özellikle sosyal koruma perspektifinden bakıldığında, 18 yaş altı bireylerin yüksek riskli içeriklerle ilişkilendirilmesinin tespitinde ciddi bir boşluk yaratmaktadır.
Bu çalışma söz konusu boşlukları bütüncül biçimde ele almakta, yerel bağlamı gözeten güven skorlama ve artımsal güncelleme düzeneklerini bir arka uç mimarisi ile birleştirmektedir. Bu bütünleşik yapı, akademik düzeyde geliştirilen yöntemleri, operasyonel olarak sürdürülebilir bir sistem mimarisine dönüştürmektedir. Sürümleme ve rollback mekanizmaları, kuyruk temelli iş yükü yönetimi ve güvenli dosya erişim politikaları gibi bileşenler, akademik yöntemlerin pratik karşılıklarını oluşturarak, sistemin ölçeklenebilirliğini ve güvenilirliğini artırmaktadır. Ayrıca Türkçe istem varyantlarının ve kültürel bağlam ayarlamalarının (örneğin mutfak-bıçak bağlamının kültürel yorum farkları) sistematik biçimde tanımlanması, yerelleştirme literatüründeki önemli bir boşluğu doldurmakta ve gelecekteki çalışmalar için yeni bir referans çerçevesi sunmaktadır.
2.5. İÇERİK MODERASYONU ve ÇOK MODELLİ YAKLAŞIMLAR
Son yıllarda, içerik moderasyonu alanındaki çalışmalar, yalnızca tekil kipli (unimodal) analizlerden çoklu-modelli (multi-modal) sistemlere doğru önemli bir dönüşüm göstermektedir. Eğitim odaklı araştırmalar yaygın olmakla birlikte, güncel literatür giderek artan biçimde görsel ve metinsel işaretlerin birlikte ele alındığı bütünleşik düzeneklere yönelmiştir. İçerik moderasyonu, zararlı veya uygunsuz içeriklerin tespiti ve filtrelenmesini amaçlayan çok boyutlu bir süreçtir; spam, nefret söylemi, şiddet, yetişkin içerik ve dezenformasyon gibi kategorilerde uygulanmaktadır. Otomatik moderasyon sistemleri, insan moderatörlerin maruz kalma riskini azaltırken verimliliği artırır; ancak yanlış pozitif (masum içeriğin engellenmesi) ve yanlış negatif (zararlı içeriğin gözden kaçması) dengesinin doğru biçimde kurulması, sistem güvenilirliği açısından kritik öneme sahiptir.
Bu bağlamda, CLIP tabanlı temsil yaklaşımları, istem (prompt) temelli sıfır-örnek (zero-shot) sınıflandırma yeteneği sayesinde, zararlı içerik, nefret söylemi veya uygunsuz sahnelerin değerlendirilmesinde esnek bir temel sunmaktadır (Radford ve diğ., 2021; Schuhmann ve diğ., 2022). CLIP, sınıf tanımlarını doğal dil ifadeleriyle temsil ettiği için yeni risk türlerine hızlı biçimde uyum sağlayabilir. Geleneksel yöntemlerde (örneğin SVM veya CNN tabanlı sınıflandırıcılar), yeni bir kategori eklemek için modelin yeniden eğitilmesi gerekirken, CLIP yalnızca yeni bir istem eklenmesiyle genişletilebilir. Bu yönüyle, model mimarisi sabit kalırken bilgi alanı dinamik biçimde genişletilebilir. Çoklu-modelli istem öğrenme (Multi-modal Prompt Learning, MaPLe) yaklaşımları ise, görsel ve metinsel istemleri eşzamanlı olarak uyarlayarak aktarım (transfer) verimliliğini artırmakta ve modelin yorumlanabilirliğini güçlendirmektedir (Khattak ve diğ., 2023). İstem mühendisliği (prompt engineering) sürecinde kullanılan tanımlamaların özgüllüğü, model performansını doğrudan etkilemektedir; örneğin genel bir istem (“violence”) belirsizlik yaratabilirken, daha spesifik bir ifade (“physical violence with weapons”) ayrıştırma gücünü artırmaktadır.
Çoklu-modalli nefret söylemi araştırmaları, metin ve görüntü arasındaki örtük ilişkilerin tespitinde tek kipli modellerin yetersiz kaldığını ortaya koymuştur. Örneğin Hateful Memes veri kümesi (Kiela ve diğ., 2020), yalnızca metne veya yalnızca görüntüye dayalı sınıflandırmaların, zımni anlam farklarını yakalayamadığını göstermiştir. Bir meme’de metin tarafsız görünebilirken, görsel saldırgan olabilmekte veya tam tersi bir durum söz konusu olabilmektedir. Bu nedenle, çoklu-modelli yaklaşımlar, her iki işaretin birlikte değerlendirilmesiyle daha güvenilir sonuçlar üretebilmektedir. Ayrıca, nesne ve sahne bağlamını hesaba katan gerçek zamanlı tespit yöntemlerinin entegrasyonu, temsil benzerliği yüksek ancak bağlamsal olarak zararsız olan içeriklerin yanlış pozitif olarak sınıflandırılmasını önleyebilmektedir. Örneğin gündelik mutfak sahnelerinde yer alan kesici aletlerin yanlış pozitif etkisi, sahne bağlamındaki mutfak nesneleri (örneğin ocak, buzdolabı, tezgâh) aracılığıyla dengelenmelidir (Redmon ve Farhadi, 2018; Wang ve diğ., 2023). Bu çalışmada geliştirilen bağlamsal ayarlama mekanizması, YOLO nesne tespiti çıktılarından elde edilen bilgiye dayalı olarak CLIP skorlarını dinamik biçimde yeniden ölçeklendirmektedir; böylece, belirli sahne bağlamlarında risk skorları uygun katsayılarla düşürülerek yanlış pozitif oranı azaltılmaktadır.
Diğer taraftan, kötü amaçlı örnek saldırıları (adversarial examples), görsel girdilerde insan gözüyle fark edilemeyecek küçük değişiklikler oluşturarak modelin tahminlerini yanıltabilmektedir (Goodfellow ve diğ., 2015). Üretim ortamında güvenilir bir moderasyon sistemi kurmak için bu tür saldırılara karşı dayanıklılığın (adversarial robustness) sağlanması zorunludur. Bu kapsamda, düşman örneklerle yeniden eğitim (adversarial training) ve defensive distillation gibi savunma stratejileri öne çıkmaktadır. Ayrıca, model açıklanabilirliği (explainability) yöntemleri, model karar süreçlerinin şeffaflığını artırarak kullanıcı güvenini güçlendirmektedir. Örneğin Grad-CAM (Selvaraju ve diğ., 2017) yöntemi, modelin hangi görüntü bölgelerine odaklandığını ısı haritası biçiminde görselleştirirken, attention map analizleri transformer tabanlı modellerde hangi yama (patch) bölgelerinin karar sürecine katkı sağladığını ortaya koymaktadır.
Bu çalışmada, OpenCLIP tabanlı temsil benzerliği, YOLO nesne ve sahne bağlamı ile kişi odaklı yaş tahmini sinyalleri bir araya getirilerek içerik analizi sürecinde çoklu-modelli bir yapı oluşturulmuştur. Geliştirilen bağlamsal ayarlama düzenekleri (örneğin “mutfak-bıçak” veya “parti-şişe” senaryoları), yanlış pozitif oranlarını azaltırken, kullanıcıya görsel açıklama desteği sağlayan YOLO tespit listesi aracılığıyla sistemin açıklanabilirliğini de güçlendirmektedir. Böylece çalışma, yalnızca sınıflandırma doğruluğunu artırmakla kalmamakta, aynı zamanda güvenilir ve kullanıcı-şeffaf bir içerik moderasyonu altyapısı sunmaktadır.
BÖLÜM 3 SİSTEM ve MİMARİ
3.1. GENEL MİMARİ
Uygulama, Python/Flask tabanlı arka uç, kalıcı veritabanı bileşeni (SQLAlchemy), eş-zamansız iş kuyruğu, gerçek zamanlı bildirim altyapısı (Flask-SocketIO) ve kalıcı dosya depolama bileşenlerinden oluşmaktadır. İstemci tarafı, HTTP/JSON ve WebSocket kanalları aracılığıyla arka uç ile iletişim kurmakta, üretim koşulları için yeniden başlatılabilirlik, idempotent başlangıç görevleri ve sürümleme mekanizmaları dikkate alınmıştır. Mimari, modüler yapısı sayesinde her bileşenin bağımsız geliştirilmesini, test edilmesini ve gerektiğinde yeniden yapılandırılmasını desteklemektedir. Bu kapsamda, routes kataloğu HTTP uç noktalarını, services iş mantığını, ai katalogu model entegrasyonlarını, utils ise yardımcı fonksiyonları barındırır; bu ayrım, separation of concerns ilkesine uygun olup bakım ve ölçeklenebilirliği kolaylaştırmaktadır.
Veritabanı katmanı (models/), ORM tabanlı soyutlama ile ilişkisel verileri yönetir; File, Analysis, ContentDetection, AgeEstimation, Feedback, ModelVersion ve CLIPTrainingSession gibi varlıklar birbirleriyle ilişkiler aracılığıyla bağlanmaktadır. Kuyruk servisi (queue_service.py), thread-safe Queue ve arka plan threadleri kullanarak eşzamanlı işleme imkânı sağlar; her iş, database_session context manager üzerinden izole SQLAlchemy oturumu ile yürütülmektedir. WebSocket servisi, Socket.IO ile oda bazlı yayın ve bağlantı yönetimi sağlamakta, emit_* fonksiyonları tüm servislerden erişilebilmekte ve merkezi socketio_instance.py üzerinden global erişim sunmaktadır. Dosya depolama altyapısı (storage/) uploads, processed ve models alt dizinleri ile düzenlenmiş, göreli yol politikası sayesinde platformlar arası uyumluluk sağlanmaktadır.
Bu genel mimari, yüksek eşzamanlılığa sahip kuyruk temelli arka plan işlemenin uç gecikmelerini azaltmadaki pratik etkilerinden yararlanmakta ve gerçek zamanlı bildirimleri oda bazlı sınırlayarak gereksiz yayın yükünü minimize etmektedir (Dean ve Barroso, 2013). Modüler yapı, yeni özelliklerin (ör. yeni risk kategorileri veya farklı model mimarileri) sisteme hızlı ve güvenli biçimde eklenmesine imkân vermekte, her modül bağımsız olarak test edilebilmekte ve gerektiğinde yeniden yapılandırılabilmektedir. Bu yaklaşım hem teknik ölçeklenebilirliği hem de operasyonel sürdürülebilirliği garanti etmektedir.
3.2. UYGULAMA YAŞAM DÖNGÜSÜ
Uygulamanın giriş noktası main.py dosyasıdır. Bu bileşen, süreç yönetimi ve sistem güvenilirliği açısından kritik olan başlatma görevlerini üstlenir: PID kaydı, sinyal yakalama (SIGTERM, SIGINT için graceful shutdown) ve çevresel günlükleme yapılandırmaları (seviyeler, formatlar, handler’lar) bu aşamada gerçekleştirilir. Ana uygulama bileşeni, app/__init__.py içindeki create_app(config_name) fonksiyonu aracılığıyla Flask örneğini ve Socket.IO sunucusunu birlikte başlatır. config_name parametresi, ‘development’, ‘testing’ ve ‘production’ gibi farklı çalışma ortamlarını temsil eder; bu esneklik, uygulamanın aynı kod tabanı üzerinde farklı dağıtım senaryolarına uyum sağlamasına olanak tanır.
Başlatma sürecini yöneten initialize_app(app) fonksiyonu yalnızca ana süreçte çalışacak şekilde tasarlanmıştır. Bu fonksiyon, veritabanı tablolarının oluşturulması ve bütünlük kontrolü (db.create_all()), gerekli depolama dizinlerinin (UPLOAD_FOLDER, PROCESSED_FOLDER, MODELS_FOLDER) var edilmesi, eski analiz çıktı ve geçici dosyaların temizliği (cleanup_old_analysis_results) ile model sürümlerinin dosya sistemi–veritabanı uyumunun sağlanması (ör. sync_age_model_versions_startup, sync_clip_model_versions_startup) görevlerini yürütür. Ayrıca kuyruk işleyicisi background thread üzerinde başlatılır; tüm bu adımlar idempotent biçimde tasarlanmıştır. Böylece uygulama yeniden başlatıldığında görevler güvenli biçimde yinelenebilir, mevcut durum korunur ve gereksiz yan etkiler oluşmaz.
Gerçek zamanlı iletişim altyapısı olan Socket.IO, app/socketio_instance.py dosyasında merkezi bir nesne üzerinden yönetilir. Bu tasarım, farklı modüllerin socket’e doğrudan erişmesini sağlarken circular import problemlerini önler. Socket.IO minimal parametrelerle yapılandırılmıştır (cors_allowed_origins="*", ping_timeout=720, ping_interval=60, async_mode='eventlet'). Eventlet monkey patching, engelleyici (blocking) I/O işlemlerini asenkron hâle getirerek uzun süren CLIP hesaplamaları sırasında dahi WebSocket bağlantısının yanıt verebilirliğini korur. Bu yapı, yüksek eşzamanlılık altında kuyruk-temelli arka plan işlemenin uç gecikmeleri düşürmesini ve gerçek zamanlı bildirimlerin oda bazlı iletimle optimize edilmesini sağlar. Sonuç olarak sistem, üretim koşullarında dayanıklı, performans açısından verimli ve yeniden başlatılabilir bir çalışma düzeni elde eder.
3.3. KONFİGÜRASYON SABİTLER, DURUM ve YOL HİYERARŞİSİ
Uygulamanın yaşam döngüsünde sürekliliği sağlayan temel bileşen, yapılandırma ve durum yönetimidir. Bu kapsamda geliştirilen config.py modülü, tüm çevresel değişkenleri, sistem yollarını ve çalışma zamanı parametrelerini merkezi olarak yönetir. .env dosyasını okuyarak geliştirme, test ve üretim ortamları arasında dinamik geçiş yapılmasına olanak tanır; log bastırma, uyarı yönetimi (örneğin TF_CPP_MIN_LOG_LEVEL, YOLO_VERBOSE) ve kaynak sınırlamaları bu katmanda tanımlanır. Aynı dosyada veritabanı bağlantısı, dosya depolama kök dizinleri (UPLOAD_FOLDER, PROCESSED_FOLDER, MODELS_FOLDER) ve içerik boyutu sınırı (500 MB) gibi temel parametreler yer alır. Bu yaklaşım, konfigürasyonun tekil bir kaynaktan yüklenmesi ilkesine dayanarak sistemin taşınabilirliğini, sürüm uyumunu ve bakım kolaylığını artırır.
Çalışma zamanı boyunca model ve analiz durumlarının tutarlı biçimde izlenebilmesi için iki hafif durum katmanı kullanılır. app/utils/model_state.py dosyası, aktif model sürümlerinin ve önbellek durumunun yönetimini gerçekleştirir; thread-safe kilitleme mekanizmasıyla eşzamanlı erişimlerden doğabilecek çakışmaların önüne geçilir. Buna paralel olarak app/utils/settings_state.py, analiz parametrelerinin ve son güncelleme zaman damgasının takibini sağlar. Parametre güncellemeleri REST API üzerinden iletildiğinde, hem app.config nesnesine hem de durum dosyasına yansıtılır; böylece geliştirme ortamında değişikliklerin otomatik yeniden yükleme yoluyla anında etkinleştirilmesi mümkün olur.
Model dizin yapısı, sistematik bir hiyerarşiyle düzenlenmiştir. Her model ailesi için temel, sürüm ve aktif yol bilgileri (BASE_PATH, VERSIONS_PATH, ACTIVE_PATH) belirlenmiş; yaş tahmini (age/buffalo_l, age/custom_age_head), içerik analizi (clip/ViT-H-14-378-quickgelu_dfn5b), nesne tespiti (detection/yolov8x) ve metin-görüntü sınıflandırması (content/openclip_classifier) gibi alt bileşenler bu yapıya entegre edilmiştir. Başlangıç senkronizasyonu aşamasında sistem, dosya sistemindeki model klasörlerini tarayarak veritabanındaki ModelVersion tablosu ile hizalar; eksik kayıtlar için yeni girişler oluşturulur, mevcut kayıtlar için ise veritabanında “aktif” olarak işaretli sürümler öncelikli kabul edilir. Böylece model dosyalarının fiziksel konumu ile veritabanı temsili arasında bütünlük korunur.
Bu yapı, yalnızca konfigürasyonun merkezi yönetimini değil, aynı zamanda sistemin operasyonel kararlılığını da güvence altına alır. Atomik güncelleme ilkesiyle çalışan model durumu mekanizması, geçici tutarsızlıkların önüne geçerken, kontrollü önbellek temizleme sayesinde bellek kullanım verimliliği sağlanır. Sonuç olarak sistem, hem yüksek düzeyde izlenebilir hem de yeni modellerin eklenmesi veya parametrelerin değiştirilmesi durumunda kesintisiz biçimde uyum sağlayabilir.
3.4. GÜNCELLENEBİLİR ANALİZ PARAMETRELERİ ve MODEL DURUMU
Uygulamanın analiz davranışı, büyük ölçüde belirli parametrelerin dengeli biçimde yönetilmesine dayanır. Bu parametreler, hem sistemin farklı veri koşullarına uyum sağlamasını hem de işlem doğruluğunun korunmasını sağlar. Tüm varsayılan değerler FACTORY_DEFAULTS sözlüğünde saklanır ve her bir parametrenin veri tipi ile geçerli aralıkları UPDATABLE_PARAMS içinde tanımlanmıştır. Bu yapı sayesinde sistem, fabrika ayarlarıyla güvenli biçimde başlar ve gerektiğinde dinamik olarak güncellenebilir hale gelir. REST tabanlı uç noktalardan gelen parametre değişiklikleri önce tür denetimine tabi tutulur; geçerliyse hem app.config içine hem de settings_state.py dosyasına atomik olarak yazılır. Her değişiklikte LAST_UPDATE zaman damgası güncellenir; geliştirme ortamında bu değişiklik Flask’in otomatik yeniden yükleme mekanizmasını tetikler ve yeni değerler anında uygulanır. Üretim ortamında ise güncellemelerin devreye alınması manuel yeniden başlatma ile gerçekleştirilir.
Parametreler, video ve görüntü analizinde modelin davranışını doğrudan etkileyen eşik değerleridir. FACE_DETECTION_CONFIDENCE, bir yüzün geçerli kabul edilmesi için gereken model güven düzeyini belirler. Varsayılan fabrika değeri 0.2’dir; bu, çoğu normal çözünürlüklü ve aydınlık sahnede güvenilir yüz tespiti sağlar. Daha düşük değerler, örneğin 0.1 civarı, algılamayı kolaylaştırır ve küçük veya kısmi yüzleri yakalayabilir ancak yanlış pozitifleri artırabilir; yüksek değerler, örneğin 0.5 veya üstü, yalnızca güçlü yüz tespitlerinin dikkate alınmasını sağlar, bu da düşük ışık veya kısmi yüzlerde kaçırma riskini doğurur.
TRACKING_RELIABILITY_THRESHOLD, kişi takibinde kimlik eşleşmesinin ne kadar güvenilir olduğuna karar verir. Fabrika değeri 0.5 olarak belirlenmiştir; bu değer, çoğu sahnede hem sürekliliği hem de yanlış kimlik oluşturma riskini dengeler. Eğer sahnede hızlı hareket veya geçici görünmezlikler varsa, değeri artırmak güvenliği artırır ancak kısa süreli kayıplarda izlemeyi kesebilir; düşürmek ise daha toleranslı takip sağlar fakat yanlış eşleşme riski artar.
ID_CHANGE_THRESHOLD, iki tespit arasındaki gömülü temsil mesafesinin hangi noktada artık farklı kişi olarak kabul edileceğini belirler. Varsayılan fabrika değeri 0.45’tir. Bu değer düşük tutulursa model farklı kişiler arasında daha hassas ayrım yapar ama aynı kişinin farklı açılardan görünen karelerinde yeni kimlik oluşturabilir; yüksek değer ise geçici açı ve pozisyon değişikliklerinde aynı kimliği korur ancak farklı kişileri karıştırma riski taşır.
MAX_LOST_FRAMES, bir kişinin kadrajdan geçici olarak kaybolduğunda sistemin kimliği kaç kare boyunca hafızada tutacağını belirler. Fabrika değeri 30 kare olarak belirlenmiştir. Bu parametre, kısa süreli kayıplarda kişi bağlantısının kopmadan sürdürülmesini sağlar. Daha düşük değerler (5-10 kare), hızlı kaybolan nesnelerde takip kopmasına yol açabilir; yüksek değerler (100-300 kare) ise uzun süre sahneden çıkmış kişiyi takip etmeye devam eder, yanlış bağlantı riskini artırır ama kesintisiz takip sağlar.
Son olarak, EMBEDDING_DISTANCE_THRESHOLD, iki yüz embedding’i arasındaki mesafenin aynı kişi kabul edilebilmesi için izin verilen üst sınırdır. Fabrika değeri 0.4 olarak belirlenmiştir; düşük değerler modelin farklı kişileri daha hassas ayırmasını sağlar, fakat düşük ışık veya düşük çözünürlükte aynı kişiyi farklı kabul etme riskini artırır. Yüksek değerler ise toleransı artırır, bu da geçici görsel bozulmalarda kimliği korumaya yardımcı olur.
Bu parametrelerin tümü, sistemin farklı veri kalitelerine ve senaryolara uyum sağlamasını mümkün kılar. Örneğin, düşük çözünürlüklü videoların analizinde FACE_DETECTION_CONFIDENCE düşürülerek daha fazla yüz algılanabilir; hızlı hareket veya kalabalık sahnelerde MAX_LOST_FRAMES ve TRACKING_RELIABILITY_THRESHOLD artırılarak kimlik sürekliliği korunabilir. Bu şekilde, analiz davranışı uygulamanın bağlamına göre dengelenebilir; sistem hem doğruluk hem de süreklilik açısından optimum noktada çalışır.
Model durumu yönetimi de aynı derecede hassas bir mekanizmadır. model_state.py dosyasında tutulan MODEL_STATE sözlüğü, her modelin aktif sürümünü ve son yükleme zamanını izler; _state_lock kullanılarak thread-safe biçimde güncellenir, böylece aynı anda birden fazla erişim olsa bile veri tutarlılığı korunur. Aktif model örnekleri _model_instances sözlüğünde önbelleğe alınır ve weak reference kullanımı, gereksiz model nesnelerinin bellekten otomatik olarak temizlenmesini sağlar, olası bellek sızıntılarını önler. Bellek temizleme işlemleri cleanup_models() fonksiyonları aracılığıyla yürütülür; CLIP, YOLO ve InsightFace modellerinin nesneleri bellekteki referanslardan arındırılır ve GPU belleği torch.cuda.empty_cache() ile boşaltılır. Versiyon geçişlerinde eski modeller önbellekte tutulmaz, reset_instance() fonksiyonu çağrılarak yeni sürüm yüklenir ve önbellek sıfırlanır. Her model aktivasyonu veya parametre değişikliğinde LAST_UPDATE zaman damgası yenilenir ve geliştirme modunda otomatik reload tetiklenir.
Sonuç olarak, güncellenebilir parametreler ile model durumu yönetimi bir bütünün iki parçası gibi çalışır: parametreler uygulamanın çevresel koşullara uyumunu sağlarken, model durumu mekanizması sistemin sürekliliğini ve kaynak güvenliğini garanti eder. Fabrika değerleri başlangıçta güvenli bir denge sunar; kullanıcı veya sistem tarafından yapılan ayarlamalar ise farklı çözünürlükler, hızlı hareket, düşük ışık veya kalabalık sahneler gibi değişken koşullarda performans ve doğruluğu optimize eder. Bu yapı, derin öğrenme tabanlı analiz süreçlerinde hem doğruluk hem de sürdürülebilirlik açısından dengeli, esnek ve açıklanabilir bir çerçeve sağlar.
3.5. VARLIK İLİŞKİ MODELİ ve DOSYA YÖNETİMİ
Uygulamanın veri yönetimi, hem analiz sonuçlarının hem de model sürümlerinin güvenli ve sistematik biçimde saklanmasını sağlayacak şekilde tasarlanmıştır. Veritabanı şeması, beş temel varlık ve ek yönetim tabloları çevresinde yapılandırılmıştır: File, Analysis, ContentDetection, AgeEstimation, Feedback, ModelVersion ve CLIPTrainingSession.
File tablosu, dosya yüklemelerinin meta verilerini içerir (filename, original_filename, file_path, file_size, mime_type, file_type, upload_date) ve her bir dosya bir veya daha fazla analiz kaydı ile ilişkilendirilebilir (1:N ilişki). Analysis, dosya üzerinde gerçekleştirilen analizlerin üst kaydını tutar; UUID ile tanımlanan id, dosya referansı (file_id), durum (status), analiz başlangıç ve bitiş zamanları, işlenen kare sayısı, saniyedeki kare oranı (frames_per_second), yaş analizini içerip içermediği (include_age_analysis), WebSocket oturumu ID’si (websocket_session_id), iptal durumu (is_cancelled) ve özet skorlar (overall_scores) gibi alanlar içerir. Her analiz birden fazla kare ve kişi tespitini barındırabilir, bu nedenle ContentDetection ve AgeEstimation tabloları ile 1:N ilişkiler kurulur.
ContentDetection tablosu, kare bazlı içerik skorlarını ve tespit edilen nesneleri JSON biçiminde saklar. Skorlar, şiddet, yetişkin içerik, taciz, silah, uyuşturucu ve güvenli içerik gibi kategorilere ayrılır. AgeEstimation, kişi bazlı yaş tahminlerini kare bilgisi, güven skoru, bounding box, işlenmiş görüntü yolu ve embedding string ile birlikte tutar. Feedback tablosu, manuel veya sözde etiketleri depolar; analiz ile ilişkilendirilebileceği gibi doğrudan yüz embedding’i üzerinden de kayıt yapılabilir. Bu yapı, hem eğitim hem de model güncelleme süreçlerinde veri kaynağının esnek kullanılmasını sağlar.
Model yönetimi için ModelVersion ve CLIPTrainingSession tabloları eklenmiştir. ModelVersion, model türü, sürüm numarası ve adı, aktiflik durumu, metrikler, kullanılan eğitim örnekleri, epoch sayısı, ağırlık dosya yolu ve kullanılan geri bildirim kimliklerini kaydeder. CLIPTrainingSession ise CLIP model eğitim oturumlarının isimlerini, metriklerini ve oluşturulma zamanlarını içerir.
İlişkiler ve kardinaliteler özetle şunlardır: bir File birden fazla Analysis içerebilir; her Analysis birden fazla ContentDetection ve AgeEstimation kaydı ile ilişkili olabilir; Feedback bağımsızdır ve isteğe bağlı olarak analiz veya doğrudan kişi bazlı kayıtlarla ilişkilendirilebilir. Cascade delete-orphan politikası, analiz silindiğinde ilişkili ContentDetection ve AgeEstimation kayıtlarının otomatik temizlenmesini sağlar. Böylece yetim kayıt birikimi engellenir. Foreign key kısıtlamaları, veri bütünlüğünü garanti eder; dosya silinmeden önce ilişkili analizlerin temizlenmesi zorunludur. İndeksler, sık sorgulanan alanlarda (ör. Analysis.status, AgeEstimation.person_id) performans optimizasyonu sağlar.
Dosya depolama hiyerarşisi, veritabanı ile entegre çalışacak şekilde tasarlanmıştır. Tüm içerik storage/ kökü altında organize edilir; yüklemeler uploads/, işlenmiş analizler processed/ ve modeller models/ dizinlerinde tutulur. Model dizinleri, taban model (base_model), sürümler (versions) ve aktif model (active_model) alt yapısı ile sürümlenebilir yapı kazandırır. Başlangıçta disk ve veritabanı kayıtları senkronize edilir; aktif model veritabanındaki kayıtlar ile hizalanır.
Güvenli dosya sunumu, göreli yol politikaları ile sağlanır. Tüm istemciye servis edilen dosyalar to_rel_path fonksiyonu aracılığıyla storage köküne göreli hale getirilir; Windows ve POSIX ayracı farklılıkları normalize edilir, böylece cross-platform uyumluluk sağlanır. Dosya uç noktaları (serve_processed_image, serve_analysis_frame, serve_uploaded_file) mutlak yol doğrulaması (to_abs_path + validate_path) ile güvenlik denetiminden geçer; path traversal veya kök dışı erişimler reddedilir. MIME türü otomatik belirlenir ve yalnızca izinli kökler üzerinden dosya sunumu yapılır. Bu çok katmanlı doğrulama hem güvenlik hem de depolama esnekliği sağlar; depolama kökü değişse bile veritabanında saklanan yollar geçerliliğini korur.
Bu bütünleşik yapı, veri bütünlüğü, sorgu performansı, güvenli dosya yönetimi ve model sürüm kontrolünü tek çatı altında toplar. Uygulama, analiz sonuçlarını güvenle depolarken, veri kaybını önler ve farklı çözünürlüklerdeki içerikler için sürdürülebilir bir çalışma ortamı sunar.
Şekil 3.5. Veri Tabanı ER Diyagramı


3.6. PLAFORM, UYGULAMA YAYINLAMA KATMANI
Uygulamanın mimarisi, geliştirme ve üretim ortamları arasında yüksek düzeyde platform bağımsızlık hedefiyle tasarlanmıştır. Geliştirme süreçleri Windows tabanlı sistemlerde yürütülürken, üretim ortamı Linux/Unix tabanlı sunucular üzerinde çalışmaktadır. Bu tercih, yapay zekâ uygulamalarının performans ve donanım erişimi açısından Linux ekosisteminde daha kararlı çalışmasıyla doğrudan ilişkilidir. GPU sürücüleri, CUDA ve cuDNN kütüphaneleri gibi düşük seviyeli hızlandırıcılar Linux’ta daha olgun bir desteğe sahiptir; ayrıca modern üretim ortamlarında yaygın olarak kullanılan Docker ve Kubernetes gibi konteyner teknolojilerinin doğal olarak bu platformlarda çalışması, sistemin gelecekte ölçeklenebilir ortamlara taşınmasını kolaylaştırmaktadır.
Uygulama çekirdeği Python dili ile geliştirilmiştir. Python’un geniş kütüphane ekosistemi, özellikle yapay zekâ tabanlı projelerde model eğitimi, veri işleme ve servis entegrasyonu alanlarında önemli avantajlar sağlar. PyTorch, dinamik hesaplama grafiği sayesinde derin öğrenme modellerinin esnek biçimde yürütülmesini mümkün kılar; yaş tahmini ve yüz tanıma süreçlerinde kullanılan InsightFace kütüphanesi bu altyapı üzerinde çalışmaktadır. TensorFlow/Keras kütüphaneleri, belirli modellerin dönüştürülmesi veya kıyaslanması için uyumlu biçimde entegre edilmiştir. OpenCV, video ve görüntü işleme aşamalarında temel araç olarak kullanılırken; NumPy ve SciPy, vektörleştirilmiş matematiksel işlemler ve istatistiksel analizler için destek sağlar. Web katmanı Flask çerçevesi üzerine kuruludur; bu yapı hem REST API uç noktalarını hem de Socket.IO aracılığıyla gerçek zamanlı bildirimleri barındırır. Veritabanı soyutlaması SQLAlchemy ORM ile sağlanmış, böylece farklı veritabanı sistemlerine geçişlerde kod düzeyinde minimal değişiklik yeterli hale getirilmiştir.
Platform bağımsızlığının sürdürülebilmesi için dosya ve yol işlemleri de özel olarak ele alınmıştır. os.path.normpath ve pathlib kullanımı sayesinde, Windows’taki ters eğik çizgi (\) ile Unix tabanlı sistemlerdeki eğik çizgi (/) farkı soyutlanmış, böylece dosya yolları her iki ortamda da uyumlu hale getirilmiştir. Çevresel değişkenler .env dosyasından yüklenmekte, DevelopmentConfig ve ProductionConfig sınıfları üzerinden ortam bazlı ayarlar (örneğin DEBUG, DATABASE_URL, USE_GPU) otomatik olarak uygulanmaktadır. Bu yapı, geliştirme, test ve üretim ortamları arasında geçişi sadeleştirirken, platform-spesifik kod bağımlılıklarını da en aza indirir.
Her ne kadar uygulama hâlihazırda tek bir güçlü GPU’ya sahip bir sunucuda çalışıyor olsa da, yazılım mimarisi container tabanlı ortamlara kolayca uyarlanabilir niteliktedir. Uygulama bağımlılıkları requirements.txt dosyasıyla tanımlanmıştır; bu sayede basit bir Dockerfile tanımı ile konteyner ortamı kısa sürede oluşturulabilir. Ortam değişkenlerinin ENV direktifleri ya da docker-compose.yml aracılığıyla dışarıdan yönetilmesi mümkündür. Statik dizinler (storage/, uploads/, processed/, models/) volume olarak bağlanabilir; böylece konteyner yeniden başlatıldığında veri bütünlüğü korunur.
Uygulama şu anda tek bir işlem örneği (instance) olarak çalışmakta ve otomatik ölçeklendirme (auto-scaling) kullanılmamaktadır. Bununla birlikte, mimari tasarım bu yeteneğe açık biçimde kurgulanmıştır. Gelecekte birden fazla GPU sunucusunun devreye alınması durumunda, Flask uygulaması yatay ölçeklenebilir hale getirilebilir; Socket.IO iletişimi için Redis tabanlı bir adapter eklenerek farklı örneklerin aynı analiz oturumlarına (örneğin analysis_<id>) eşzamanlı veri yayınlaması sağlanabilir. Veritabanı katmanı da benzer biçimde PostgreSQL veya MySQL gibi harici servislerle genişletilebilir; SQLAlchemy soyutlama katmanı bu geçişi kod düzeyinde neredeyse etkisiz kılar.
Ayrıca, sisteme entegre edilecek bir /health uç noktası, konteyner orkestrasyon araçları (Kubernetes Liveness/Readiness Probes) tarafından sağlık kontrolü amacıyla kullanılabilir. Böylece ilerleyen aşamalarda sistemin cloud-native veya on-premises altyapılarda izlenmesi ve ölçeklenmesi kolaylıkla sağlanabilir.
Sonuç olarak, sistem şu anda tekil donanım kaynakları üzerinde çalışmakta olsa da, tüm yapısal kararlar gelecekteki olası genişlemeleri öngören biçimde alınmıştır. Seçilen teknolojiler, hem mevcut kurulumun kararlı biçimde işlemesini hem de gelecekteki konteyner tabanlı dağıtımlar, yüksek erişilebilirlik senaryoları ve dağıtık GPU altyapıları için güçlü bir temel oluşturur.

3.7. KATMANLI MİMARİ ve VERİ AKIŞI
Sistem mimarisi, katmanlı yapı (layered architecture) ilkesine dayanmaktadır; bu tasarım, her katmanın belirli sorumlulukları üstlenmesi ve katmanlar arası arayüzlerin net tanımlanmasıyla bakım kolaylığı ve genişletilebilirlik sağlar. Mimari, dört temel katmandan oluşmaktadır: İstemci/UI Katmanı, Orta Katman, Arka Katman ve Veri/Model Katmanı.

İstemci/UI katmanı, web tarayıcısı üzerinde çalışan kullanıcı arayüzünü kapsar. Bootstrap framework'ü ile responsive tasarlanmış arayüz, dosya yükleme, analiz başlatma, sonuç görüntüleme ve geri bildirim gönderme işlevlerini sunar. Socket.IO client kütüphanesi, gerçek zamanlı bildirimler için WebSocket bağlantısını yönetir; AJAX (fetch API) ile REST uçlarına asenkron istekler gönderir. Bu katman, kullanıcı deneyimine odaklanır; teknik detaylar soyutlanır ve basit, anlaşılır etkileşimler sunulur.

Orta katman, HTTP isteklerini karşılayan REST API, gerçek zamanlı bildirimleri yöneten Flask-SocketIO ve iş yükü dengelemesini sağlayan kuyruk orkestrasyon bileşenlerini barındırır. REST API (app/routes/*), dosya yükleme, analiz başlatma/iptal/durum sorgulama, geri bildirim gönderme, model sürüm yönetimi gibi uç noktaları tanımlar. Socket.IO, oda bazlı yayın (room-based broadcasting) ile her analiz için ayrı bir kanal oluşturur; ilerleme güncellemeleri yalnızca ilgili odaya gönderilir, gereksiz yayın trafiği önlenir. Kuyruk servisi (app/services/queue_service.py), thread-safe Queue ile FIFO düzeninde işleri arka katmana iletir; her iş Flask uygulama bağlamında (app_context) ve izole veritabanı oturumuyla (database_session context manager) işlenir. Bu katman, eşzamanlılık yönetimi ve hata izolasyonu açısından kritik rol oynar.

Arka katman, yapay zekâ modellerini ve eğitim servislerini içerir. ContentAnalyzer (app/ai/content_analyzer.py), OpenCLIP ve YOLO ile içerik risk skorları üretir; InsightFaceAgeEstimator (app/ai/insightface_age_estimator.py), Buffalo-L ve Custom Age Head ile yaş tahmini yapar. Eğitim servisleri (app/services/incremental_age_training_service_v2.py, app/services/age_training_service.py), kullanıcı geri bildirimlerini ve yüksek güvenli pseudo-label'ları kullanarak artımsal model güncellemesi gerçekleştirir. Bu katman, hesaplama yoğun işlemleri yürütür; GPU bellek yönetimi (CLIP paylaşımı) ve asenkron işleme (ThreadPoolExecutor) ile performans optimize edilir.

Veri/Model katmanı, kalıcı veri deposu (SQLAlchemy ORM ile yönetilen SQLite/PostgreSQL), dosya depolama (storage/uploads, storage/processed) ve model sürüm deposunu (storage/models/age, storage/models/clip, storage/models/detection) kapsar. Veritabanı şeması, File, Analysis, ContentDetection, AgeEstimation, Feedback, ModelVersion ve CLIPTrainingSession tablolarından oluşur; ilişkiler cascade delete-orphan ile yönetilir (bkz. 3.5). Model dizin yapısı base_model/, versions/ ve active_model/ alt dizinleriyle sürümlenebilir; başlangıç senkronizasyonu dosya sistemi ile veritabanını hizalar (sync_age_model_versions_startup, sync_clip_model_versions_startup).

Veri akışı, kullanıcının dosya yüklemesiyle başlar; REST API dosyayı validate_path ile doğrular, MIME/magic-bytes kontrolü yapar ve benzersiz adla storage/uploads altına kaydeder. File kaydı veritabanına yazılır. Kullanıcı analiz başlattığında, Analysis kaydı "pending" durumunda oluşturulur ve kuyruk servisine eklenir. WebSocket üzerinden analysis_started olayı yayınlanır. Kuyruk işleyicisi görevi alır; dosya türüne göre (görsel/video) analiz yöntemini seçer. ContentAnalyzer.analyze_image çağrılır; CLIP ile görsel özellikler çıkarılır, classification head veya prompt-based yöntemle kategorik skorlar üretilir, YOLO ile nesne tespiti yapılır, bağlamsal ayarlamalar (mutfak-bıçak, parti-şişe) uygulanır. Yaş analizi etkinse, InsightFaceAgeEstimator yüzleri tespit eder; Buffalo-L ve Custom Head tahminleri çapraz sorgu ile karşılaştırılır, yüksek güven skorlu seçilir. Sonuçlar ContentDetection ve AgeEstimation kayıtlarına yazılır. İlerleme güncellemeleri analysis_progress olayıyla yayınlanır. Tamamlandığında analysis.status "completed" olur, genel skorlar (overall_scores) ve en riskli kare (highest_risk_frame) alanları doldurulur, analysis_completed olayı gönderilir. İstemci, REST üzerinden detay sonuçları alır ve overlay görsellerini görüntüler.

Bu katmanlı yapı, separation of concerns ilkesine dayanır; her katman belirli bir sorumluluk alanına sahiptir ve katmanlar arası arayüzler (REST/JSON, WebSocket/event, Python fonksiyon çağrıları, SQL sorguları) net tanımlanmıştır. Bu yaklaşım, birim ve entegrasyon testlerini kolaylaştırır; her katman bağımsız mock'lanabilir ve test edilebilir (tests/test_ai_modules.py, tests/test_analysis_service.py, tests/test_api_integration.py). Ayrıca yeni özelliklerin (ör. yeni risk kategorisi, farklı model mimarisi) eklenmesi, yalnızca ilgili katmanı etkileyerek değişiklik riskini azaltır. Modüler yapı, yatay ölçekleme imkânı tanır; gelecekte orta katman ve arka katman farklı sunuculara dağıtılabilir, Redis adapter ile Socket.IO çoklu instance'da çalışabilir.

3.8. SEQUENCE ve STATE DİYAGRAMLARI
Sistemin dinamik davranışı, sequence (sıra) diyagramları ve state (durum) diyagramları ile modellenmektedir. Sequence diyagramları, bileşenler arası mesaj akışını zaman sırasıyla gösterirken; state diyagramları, nesnelerin yaşam döngüsündeki durum geçişlerini ve tetikleyicileri ortaya koyar.

Dosya yükleme ve analiz başlatma akışı şu adımlarla gerçekleşir: Kullanıcı (UI), POST /api/files isteği ile dosya ve auto_analyze parametresini REST API'ye gönderir. REST API, dosyayı DB/Storage'a kaydeder ve file_id döndürür. Kullanıcı, POST /api/analysis/start isteği ile file_id, frames_per_second ve include_age_analysis parametrelerini gönderir. REST API, Analysis kaydını oluşturur, görevi kuyruğa ekler (Queue) ve Socket.IO'ya analysis_started olayını tetikler. Kuyruk, AI servislerine (ContentAnalyzer, InsightFaceAgeEstimator) görevi iletir; modeller analiz yapar ve sonuçları DB/Storage'a yazar. Kuyruk, ilerleme (analysis_progress) ve tamamlanma (analysis_completed) olaylarını Socket.IO'ya gönderir. Socket.IO, bu olayları kullanıcıya gerçek zamanlı olarak iletir.

Model sürüm aktivasyonu akışı daha kısadır: Yönetici (UI), POST /api/models/<type>/activate isteği ile version_id gönderir. REST API, Model Service'e activate komutunu iletir. Model Service, ModelVersion tablosunda aktif sürümü işaretler ve yeni modeli yükler. Başarı mesajı REST API'den kullanıcıya döndürülür.

Analiz yaşam döngüsü state diyagramı, bir Analysis kaydının durumlarını ve geçişleri tanımlar: PENDING (başlangıç durumu), RUNNING (kuyruğa alınıp işlemeye başlandığında), COMPLETED (sonuçlar başarıyla yazıldığında), FAILED (hata/istisna oluştuğunda), CANCELLED (kullanıcı iptal ettiğinde). PENDING'den RUNNING'e geçiş, kuyruğun işi almasıyla tetiklenir; RUNNING'den COMPLETED'e geçiş, tüm karelerin işlenip sonuçların veritabanına yazılmasıyla; RUNNING'den FAILED'e geçiş, beklenmeyen hata (ör. dosya bozuk, GPU bellek yetersiz) ile; RUNNING'den CANCELLED'e geçiş, kullanıcının iptal butonu veya WebSocket kopuşuyla gerçekleşir. Her durum geçişinde ilgili WebSocket olayı (analysis_started, analysis_progress, analysis_completed, analysis_failed, analysis_cancelled) yayınlanır.

Bu diyagramlar, sistemin davranışını açık biçimde belgeler; yeni geliştiricilerin iş akışını anlamasını kolaylaştırır, hata ayıklama süreçlerinde hangi bileşenin hangi adımda devreye girdiğini netleştirir ve test senaryolarının tasarımına rehberlik eder. UML ve Mermaid syntax kullanımı, diyagramların metin tabanlı versiyon kontrolüne uygun olmasını sağlar; değişiklikler git diff ile takip edilebilir.

3.9. DAĞITIM MİMARİSİ ve ON-PREMISES KURULUM
Sistemin dağıtım mimarisi, on-premises (kurum içi) topoloji ile tasarlanmıştır; kişisel verilerin kurum dışına çıkmaması gereksinimi (KVKK uyumu) bu kararın temel gerekçesidir. Tek bir sunucu üzerinde şu bileşenler konumlandırılmıştır: Nginx/Reverse Proxy (HTTPS sonlandırma, rate limiting, static asset caching), Flask + Socket.IO (uygulama servisi), Queue Workers (arka plan analiz işleyicileri), RDBMS (SQLite/PostgreSQL), dosya sistemi (storage/).

İstemci (Browser), HTTPS üzerinden Nginx'e bağlanır. Nginx, statik dosyaları (CSS, JS, resim) doğrudan servis eder; dinamik istekleri WSGI/HTTP protokolü ile Flask uygulamasına iletir. Flask, SQLAlchemy ile veritabanına, filesystem API ile storage dizinlerine erişir. Kuyruk işleyicileri, Flask uygulama bağlamında çalışır; AI modellerini yükler, analiz yapar ve sonuçları veritabanı/dosya sistemine yazar. Socket.IO, Nginx üzerinden WebSocket/polling ile istemciye gerçek zamanlı olaylar gönderir.

Windows kurulumu (geliştirme ortamı): Python 3.10–3.11 kurulumu, venv ile sanal ortam oluşturma, pip install -r requirements.txt ile bağımlılıklar, python scripts\\download_models.py ile model indirme, .env dosyası oluşturma (FLASK_ENV=development, USE_GPU=false/true), python app.py ile başlatma. Sorun giderme: port çakışması durumunda FLASK_RUN_PORT=5001, GPU yoksa USE_GPU=false.

Linux kurulumu (üretim ortamı, Ubuntu 22.04): Sistem paketleri (python3-venv, python3-pip), venv oluşturma, pip install -r requirements.txt, model indirme, .env oluşturma (FLASK_ENV=production, USE_GPU=true), FLASK_ENV=production python app.py veya gunicorn wsgi:app --worker-class eventlet -w 1 --bind 0.0.0.0:5000 ile başlatma. Systemd servis dosyası (/etc/systemd/system/wsanaliz.service): WorkingDirectory=/opt/wsanaliz, ExecStart=/opt/wsanaliz/venv/bin/python app.py, Restart=always, Environment=FLASK_ENV=production. Servis başlatma: sudo systemctl start wsanaliz, otomatik başlatma: sudo systemctl enable wsanaliz. Sağlık kontrolü: bash health_check.sh veya curl http://localhost:5000/health.

Ortak kurulum adımları: Dizin yapısı oluşturma (mkdir -p storage/uploads storage/processed storage/models), model sürüm senkronizasyonu (uygulama ilk başlatıldığında otomatik), GPU yoksa CPU fallback (sistem otomatik algılar, torch.cuda.is_available() kontrolü), izin sorunları (Linux'ta chown -R wsanaliz:wsanaliz /opt/wsanaliz), port kullanımı (5000 varsayılan, gerekirse değiştirilebilir).

Bu kurulum prosedürleri, uygulamanın farklı ortamlarda tekrarlanabilir biçimde ayağa kaldırılmasını sağlar. Geliştirme ortamında hızlı iterasyon (otomatik reload), üretim ortamında kararlılık (systemd, sağlık kontrolü, graceful shutdown) önceliklidir. Container tabanlı dağıtım için Dockerfile ve docker-compose.yml örnekleri gelecek çalışmalarda eklenebilir; mevcut yapı zaten container-uyumludur (requirements.txt, .env, volume mount için hazır dizinler).

BÖLÜM 4 YAPAY ZEKÂ MODÜLLERİ ve EĞİTİM

4.1. İÇERİK ANALİZİ (OpenCLIP)
Bu bölüm, içerik risk kategorilerinin (şiddet, yetişkin içerik, taciz, silah, uyuşturucu) otomatik tespiti için kullanılan OpenCLIP tabanlı analiz sistemini detaylandırmaktadır. Bölüm 2.2'de teorik altyapısı sunulan CLIP modeli, burada uygulama düzeyinde ele alınmaktadır.

ContentAnalyzer sınıfı (app/ai/content_analyzer.py), singleton pattern ile tasarlanmıştır; thread-safe double-checked locking ile tek bir örnek oluşturulur, tüm servisler bu örneği paylaşır. Model yükleme, _load_clip_model fonksiyonu ile gerçekleşir; ViT-H-14-378-quickgelu mimarisi dfn5b ağırlıklarıyla başlatılır. ViT-H, Vision Transformer'ın "Huge" varyantıdır; 632M parametre, 32 transformer layer, 16 attention head içerir. Patch size 14×14, hidden dimension 378'dir. Bu büyük model seçimi, içerik moderasyonunda ince semantik ayrımlar (ör. şiddet vs. spor, yetişkin içerik vs. sanat) için gereklidir; küçük modeller (ViT-B/32) hız kazandırır ancak ayrıştırma gücü azalır (Dosovitskiy ve diğerleri, 2021).

Ön-eğitim veri seti LAION-5B'dir; 5.85 milyar görüntü-metin çifti, 100+ dil desteği içerir (Schuhmann ve diğerleri, 2022). Kontrastif öğrenme ile eğitilmiş model, metin ve görüntüyü ortak embedding uzayında temsil eder; sıfır-örnek sınıflandırma yapabilir. Fine-tuned ağırlıklar mevcutsa (storage/models/clip/active_model/open_clip_pytorch_model.bin) yüklenir; bu dosya kurum-spesifik veri ile eğitilmiş classification head içerir.

Classification head, CLIP görsel özelliklerini (1024-dim) beş risk kategorisine dönüştürür. Mimari: Linear(1024→512) → ReLU → Dropout(0.2) → Linear(512→256) → ReLU → Dropout(0.2) → Linear(256→5) → Sigmoid. Multi-label classification için sigmoid kullanılır; her kategori bağımsız [0,1] olasılık alır. Eğitim, WeightedBCELoss ile yapılır; sınıf ağırlıkları dengesiz dağılımı düzeltir. Fine-tuning süreci: Üretim analizlerinden toplanan geri bildirimler (2000-5000 örnek), her kategori için dengeli dağılım, 20 epoch, batch_size=32, learning_rate=1e-4, AdamW optimizer, CosineAnnealingLR scheduler (Loshchilov ve Hutter, 2017; Smith, 2017). Dropout (0.2), overfitting önler (Srivastava ve diğerleri, 2014).

Prompt engineering, kategorilere özgü pozitif ve negatif istemler tasarlar. Örneğin violence için pozitif: "physical violence", "fighting and aggression", "violent confrontation"; negatif: "peaceful interaction", "calm and safe environment". Her kategori için 5 pozitif, 5 negatif istem tanımlanır. Tokenizer (open_clip.get_tokenizer) istemleri tokenize eder, text encoder embedding'leri üretir, görsel embedding ile kosinüs benzerliği hesaplanır. Pozitif skorlar ortalaması ile negatif skorlar ortalaması arasındaki fark (Δ = pos_avg - neg_avg) tanh ile [-1,1]'e sıkıştırılır, [0,1] aralığına taşınır ve MIN/MAX eşikleriyle normalize edilir (Radford ve diğerleri, 2021).

YOLO bağlamsal ayarlamaları, nesne tespiti bilgisini kullanarak skorları düzeltir. Kod referansı: _apply_contextual_adjustments fonksiyonu. Mutfak bağlamında bıçak ("knife" in object_labels and "kitchen" in object_labels) tespiti durumunda weapon ve violence skorları düşük çarpanla artırılır (0.3, 0.5); genel silah tespitinde ("gun", "rifle" in object_labels) yüksek çarpan (1.5, 1.3) uygulanır. Kişi sayısı < 2 ise harassment düşürülür (tek kişi taciz edemez mantığı). CLIP yüksek weapon skoru üretir ama YOLO silah görmezse, skor 0.2-0.7 çarpanla düşürülür; yanlış pozitif riski azaltılır (Redmon ve Farhadi, 2018; Wang ve diğerleri, 2023).

Ensemble entegrasyonu (opsiyonel), base skorları düzeltir. Ensemble service mevcutsa, her kategori için base_description ve base_confidence ensemble_service.predict_content_ensemble'a gönderilir; düzeltilmiş skor döndürülür. Bu mekanizma, birden fazla CLIP modelinin uzlaşısı ile güvenilirliği artırır.

Safe skoru, risk kategorilerinin tersi olarak hesaplanır: risk_sum = violence + adult_content + harassment + weapon + drug; average_risk = risk_sum / 5; safe_score = max(0.0, 1.0 - average_risk). Bu yaklaşım, sahnenin genel güvenlik seviyesini tek bir metrikle özetler.

Kod doğrulama: app/ai/content_analyzer.py, __init__ fonksiyonu (satır 106–244), analyze_image fonksiyonu (satır 387–577), _apply_contextual_adjustments fonksiyonu (satır 579–690). Tüm açıklamalar kod ile doğrulanmıştır.

4.2. YÜZ ve YAŞ TAHMİNİ (InsightFace + Özel Başlık)
Yaş tahmini sistemi, InsightFace Buffalo-L temel modeli ile kurum-spesifik Custom Age Head başlığının birleşiminden oluşmaktadır. Bölüm 2.2'de teorik altyapısı sunulan InsightFace, burada uygulama detaylarıyla ele alınmaktadır.

InsightFaceAgeEstimator sınıfı (app/ai/insightface_age_estimator.py), Buffalo-L boru hattını kullanır. Buffalo-L, üç ana bileşen içerir: det_10g.onnx (yüz tespiti, RetinaFace mimarisi), rec.onnx (yüz tanıma, ResNet-based, 512-dim embedding), genderage.onnx (yaş/cinsiyet tahmini, lightweight CNN). RetinaFace, multi-scale feature pyramid ile farklı boyutlardaki yüzleri tespit eder; FACE_DETECTION_CONFIDENCE eşiği (varsayılan 0.5) ile filtreleme yapılır (Deng ve diğerleri, 2019b). ArcFace loss ile eğitilmiş rec.onnx, yüz ROI'sinden (112×112) 512-boyutlu embedding üretir; açısal marjinal yumuşatma ile benzer yüzler temsil uzayında sıkı kümelenir, farklı bireyler belirgin ayrılır (Deng ve diğerleri, 2019a). Genderage.onnx, genel popülasyon için baseline yaş tahmini yapar; bu tahmin, Custom Age Head ile çapraz doğrulanır.

Custom Age Head, 512-boyutlu embedding üzerinde çalışan hafif ağdır. Mimari: Linear(512→256) → ReLU → Dropout(0.2) → Linear(256→128) → ReLU → Dropout(0.2) → Linear(128→1). Regresyon çıktısı (output_dim=1), yaş değerini doğrudan tahmin eder. Parametre sayısı ~200K olup büyük modellere göre hafiftir; artımsal güncellemelerde hızlı yakınsama sağlar. UTKFace veri kümesi (~23.000 etiketli yüz, 0-116 yaş aralığı) ile ön-eğitilir; final metrikler MAE≈2.7-2.9, MSE≈10.9-12.6, ±5y accuracy≈87-88% seviyesindedir. Kurum içi feedback ve pseudo-label'larla artımsal eğitim yapıldıkça (v1, v2, ...) kurum-spesifik performans artar (Pan ve Yang, 2010; Howard ve Ruder, 2018).

Model yönetimi, storage/models/age/ altında şu yapıyla organize edilir: buffalo_l/ (InsightFace base model), custom_age_head/ (base_model/, versions/, active_model/). Her eğitim turu yeni sürüm üretir; ModelVersion tablosuna kaydedilir (version, version_name, is_active, metrics, used_feedback_ids). Aktif sürüm, model_service.py ve model_state.py ile yönetilir; rollback basit bir API çağrısıyla gerçekleşir.

CLIP paylaşımı (set_shared_clip), ContentAnalyzer'dan InsightFaceAgeEstimator'a CLIP modelini enjekte eder; ikinci bir kopya yüklenmez, GPU belleği ~8-12 GB tasarruf sağlanır. Paylaşım, yalnızca inference'da kullanılır; eğitim sırasında her modül bağımsız çalışır. Kod: InsightFaceAgeEstimator.set_shared_clip(clip_model, clip_preprocess, tokenizer) (app/ai/insightface_age_estimator.py, satır 238–250).

Çapraz sorgu yaklaşımı, Buffalo-L ve Custom Head tahminlerini karşılaştırır. Her model kendi çıktısı için CLIP güveni hesaplar; ardından her model diğerinin tahminini doğrular. Net skorlar (kendi pozitif - karşıt negatif) karşılaştırılır; yüksek net skoru veren seçilir. Bu mekanizma, Bölüm 2.3'te teorik olarak tanımlanan model uzlaşısının pratik uygulamasıdır. Kod: _calculate_confidence_with_clip fonksiyonu (app/ai/insightface_age_estimator.py, satır 465–551).

Pseudo-label paketi, yüksek güvenli yaş tahminlerini otomatik etiketler. Yapı: person_id, estimated_age, clip_confidence, final_weight, created_at, source_analysis_id. CLIP güveni PSEUDO_LABEL_RECORD_CLIP_THRESHOLD (0.75) üstündeyse Feedback tablosuna kaydedilir; training_status="pending" olarak işaretlenir. Eğitimden önce kalite filtresi: yaş aralığı dengelenir (0-18, 18-30, 30-45, 45-60, 60+), final_weight < w_min olanlar atılır. Bu yaklaşım, Bölüm 2.3'te açıklanan Confident Learning metodolojisinin uygulamasıdır (Northcutt ve diğerleri, 2021).

Feedback döngüsü, kullanıcı düzeltmeleri ile artımsal öğrenme sağlar. Kullanıcı, overlay görseli üzerinde yaşı düzeltir; kayıt Feedback tablosuna (feedback_type="age", feedback_source="MANUAL_USER") yazılır. Periyodik olarak (ör. haftalık) son N gün feedback'leri toplanır, kişi bazlı tekilleştirilir (aynı person_id için en güncel manual feedback tercih edilir), yaş aralığına göre dengelenir ve train_incremental_model fonksiyonuna gönderilir (app/services/incremental_age_training_service_v2.py, satır 188-303). Ağırlıklı MSE kaybı (loss_per_sample * confidence_weights).mean() ile eğitilir; yüksek güvenli örnekler eğitime daha fazla katkı sağlar. Yeni sürüm ModelVersion tablosuna kaydedilir; doğrulama seti MAE'si önceki sürümden düşükse aktif edilir, artışsa rollback yapılır. Bu döngü, modelin kurum verisine hızla uyumunu ve manuel etiketleme yükünün azalmasını sağlar.

Hata toleransı ve fallback: CLIP yüklenemezse, Buffalo-L genderage.onnx varsayılan güven (0.5) ile kullanılır. Custom Head yüklenemezse, base model (UTKFace ön-eğitimli) kullanılır. Yüz tespit edilemezse, yaş analizi atlanır ve yalnızca içerik analizi yürütülür. CLIP güven hesaplanamaz veya timeout olursa, varsayılan güven (0.5) döndürülür. GPU bellek yetersizse (CUDA OOM), cleanup_models tetiklenir, modeller bellekten arındırılır ve torch.cuda.empty_cache() çağrılır. Bu stratejiler, üretim sürekliliğini korur; hata kayıtları log'da ve audit izinde işaretlenir.

Kod doğrulama: app/ai/insightface_age_estimator.py, __init__ (satır 57–235), estimate_age (satır 262–463), _calculate_confidence_with_clip (satır 465–551), set_shared_clip (satır 238–250). Tüm açıklamalar kod ile doğrulanmıştır.

4.3. EĞİTİM DÖNGÜSÜ ve AĞIRLIKLI KAYIP
Hafif başlığın eğitimi, artımsal (incremental) yaklaşımla yürütülür; bu sayede modelin önceki bilgilerini unutmadan (catastrophic forgetting) yeni verilerle güncellenmesi amaçlanır. Bölüm 2.2'de teorik olarak ele alınan artımsal öğrenme, burada ağırlıklı kayıp ve erken durdurma ile uygulanmaktadır.

Eğitim verisi, Feedback tablosundan hazırlanır. prepare_feedback_data fonksiyonu, age ve age_pseudo türlerini alır, kişi bazlı tekilleştirir (aynı person_id için en güncel manual feedback öncelikli), embedding alanını (virgülle ayrılmış string) numpy array'e dönüştürür, yaş değeri [0,100] aralığı dışında kalanları eler. Embedding'ler L2 norm ile normalize edilir (X = X / ||X||₂); bu adım kritiktir, inference'da da aynı normalizasyon uygulanır, tutarlılık gereklidir.

Ağırlıklı kayıp formülü: L = (1/N) Σ w_i * (f(x_i) - y_i)²; w_i = γ * C_final(x_i) + (1-γ). γ≈0.8-1.0 tercih edilir; yüksek değer güven skorunun belirleyici olmasını sağlar. Kod referansı: incremental_age_training_service_v2.py, train_incremental_model fonksiyonu (satır 188-303). Eğitim döngüsü: optimizer.zero_grad(), outputs = model(batch_X), loss_per_sample = criterion(outputs, batch_y).squeeze(), weighted_loss = (loss_per_sample * batch_weights).mean(), weighted_loss.backward(), optimizer.step(). Criterion: nn.MSELoss(reduction='none'), örnek-bazlı kayıp hesaplar.

Erken durdurma (early stopping): Doğrulama kaybı (val_loss) patience çevrim (varsayılan 10) boyunca iyileşmezse eğitim durdurulur. En iyi doğrulama kaybının görüldüğü noktadaki ağırlıklar (best_model_state) saklanır ve eğitim sonunda geri yüklenir. Bu mekanizma, overfitting'i önler; validation loss artmaya başladığında (erken işaret) eğitim kesilir.

IncrementalAgeModel mimarisi, dondurulmuş base model (UTKFace eğitimli) ve fine-tune branch'ini birleştirir. Fine-tune branch: Linear(512→128) → ReLU → Dropout(0.3) → Linear(128→64) → ReLU → Dropout(0.3) → Linear(64→1). Mix_weight öğrenilebilir parametresi (torch.nn.Parameter), iki dalın katkısını dengeler: final_pred = (1-sigmoid(mix_weight)) * base_pred + sigmoid(mix_weight) * fine_pred. Başlangıçta weight≈0.2 (%20 fine, %80 base); eğitim ilerledikçe kurum verisine uyum güçlenir.

Eğitim sonunda final değerlendirme: val_mae, val_mse, ±3y accuracy, ±5y accuracy hesaplanır. Metrikler training_details.json dosyasına yazılır; ModelVersion tablosuna kaydedilir. Test seti (kurum içi 8K kontrol seti) üzerinde MAE izlenir; önceki sürümden düşükse yeni sürüm aktif edilir (app/services/model_service.py), artışsa rollback yapılır (Kirkpatrick ve diğerleri, 2017; Rebuffi ve diğerleri, 2017; Li ve Hoiem, 2016).

Kod doğrulama: app/services/incremental_age_training_service_v2.py (satır 1-303), app/scripts/train_custom_age_head.py (UTKFace ön-eğitim). Tüm açıklamalar kod ile doğrulanmıştır.

BÖLÜM 5 GÜVEN SKORU ve VERİ KALİTESİ

5.1. ÇOK-MODELLİ UZLAŞI (Agreement)
İki modelin yaş tahminleri arasındaki uyum, veri kalitesi ve model güvenilirliğinin önemli bir göstergesidir. Buffalo-L ve Custom Age Head farklı eğitim süreçleri ve veri kümelerinden gelir; bu nedenle tahminlerinin yakınlığı, örneğin güvenilirliğini işaret eder. Teorik olarak, uzlaşı puanı mutlak farkın üstel azaltımıyla tanımlanır: C_agreement(x) = exp(-|y₁ - y₂|/σ). Burada σ duyarlılık parametresi olup, σ=2.0 değeri yaş tahmini için makul bir başlangıç noktası sağlar. Üstel azalma fonksiyonu monoton azalan, sürekli ve türevlenebilirdir; büyük farklarda hızlı azalma gösterir. Örneğin 0 yıl fark için C=1.0, 2 yıl için C≈0.368 (σ=2.0), 5 yıl için C≈0.082, 10 yıl için C≈0.007 üretir. Alternatif metrikler (L1, L2, kosinüs benzerliği) de değerlendirilebilir; üstel azalma büyük farklarda daha hızlı ceza, küçük farklarda yumuşak geçiş ve parametrik ayarlanabilirlik avantajları sağlar.

Kodda pratik bir "çapraz sorgu" yaklaşımı uygulanır (app/ai/insightface_age_estimator.py, _calculate_confidence_with_clip fonksiyonu). Buffalo-L tahmini y₁ ve Custom Age Head tahmini y₂ üretilir; her modelin kendi çıktısı için CLIP güveni hesaplanır. Ardından her model diğerinin tahminini doğrular (Buffalo-L, y₂ istemlerine karşı negatif skor elde eder; Custom Head, y₁ istemlerine karşı negatif skor elde eder). Net skorlar (kendi pozitif - karşıt negatif) karşılaştırılır; yüksek net skoru veren seçilir. Eğer her ikisi de düşük güvenle kalırsa Buffalo-L varsayılan olur. Bu mekanizma, üretimde aşırı uyum riskini sınırlar ve temel model daima güvenli bir geri düşüş noktası olarak kalır. Teorik üstel formül yerine bu seçmeli prosedür, üretim koşullarında daha kararlı karar verir.

5.2. CLIP TABANLI ANLAMSAL DOĞRULAMA
CLIP, metin ve görüntüyü ortak embedding uzayında temsil eder; bu sayede doğal dil ile görsel içerik arasındaki semantik benzerlik ölçülebilir. Görüntü-metin gömülerinin kosinüs benzerliği 0-100 aralığına ölçeklenir: S(I,T) = 100 * cos(E_img(I), E_text(T)). Kosinüs benzerliği iki vektör arasındaki açının kosinüsü olup, 1.0 aynı yön (mükemmel uyum), 0.0 dik açı (ilgisizlik), -1.0 zıt yön (çelişki) anlamına gelir. CLIP modelinde vektörler L2 norm ile birim vektöre dönüştürüldüğü için payda 1 olur ve iç çarpım doğrudan kosinüs değerini verir; bu normalizasyon ölçek bağımsız karşılaştırma sağlar (Radford ve diğerleri, 2021).

Prompt engineering, kategorilere ve yaş aralıklarına özgü istemler tasarlar. Yaş tahmini için pozitif istem: "this face is 35 years old", "this person appears to be 35 years old"; negatif istemler komşu aralıklar: "this face is 18 years old", "this face is 60 years old", "this person looks much younger/older". İçerik analizi için violence pozitif: "Is there physical violence in this frame?", "fighting and aggression"; negatif: "peaceful interaction", "calm and safe environment". Her kategori için 5 pozitif, 5 negatif istem tanımlanır. Tokenizer (open_clip.get_tokenizer) istemleri tokenize eder, text encoder embedding'leri üretir, görsel embedding ile kosinüs benzerliği hesaplanır.

CLIP güven skoru hesaplama süreci: (1) Her prompt tokenize edilir, (2) Text encoder ile embedding üretilir, (3) Görüntü CLIP image encoder ile embedding üretilir, (4) Kosinüs benzerliği (similarities = 100.0 * image_features @ text_features.T) hesaplanır, (5) Pozitif skorlar ortalaması ile negatif skorlar ortalaması arasındaki fark (Δ = max(S_pos) - max(S_neg)) hesaplanır. Ham fark sınırsız olabilir; sigmoid normalizasyonu ile [0,1] aralığına taşınır: C_clip(x) = 1 / (1 + exp(-2Δ)). Duyarlılık katsayısı (2), küçük farklarda bile ayrıştırma sağlar; Δ=0'da C=0.5 (belirsiz), Δ=2'de C≈0.982 (yüksek güven), Δ=-2'de C≈0.018 (düşük güven). Final güven 0.1-0.9 ile sınırlandırılır; aşırı uçların etkisi yumuşatılır.

Kod doğrulama: app/ai/insightface_age_estimator.py, _calculate_confidence_with_clip fonksiyonu (satır 465-551). Benzerlik skorları hesaplama (satır 513-514), ham fark (satır 522), sigmoid normalizasyon (satır 529), sınırlama (satır 530). Tüm açıklamalar kod ile doğrulanmıştır.

5.3. ROC/PR EŞİK UYGULAMASI ve KARAR KURALLARI
Bölüm 2.3'te sunulan ROC (Receiver Operating Characteristic) ve PR (Precision-Recall) eğrisi teorisi, bu çalışmada üretim akışında τ=0.75 eşiği ile uygulanmıştır (bkz. Şekil 2.3). Deneysel olarak belirlenen bu eşik değeri, veri kalitesi odaklı yaklaşımın miktar odaklı yaklaşıma üstünlüğünü sağlamakta; yüksek precision ile gürültü azaltılırken, makul recall ile yeterli örnek seçimi korunmaktadır.

Üç aşamalı karar kuralı uygulanır: (1) Yüksek güven (C_final ≥ 0.75): Eğitimde kullanılacak yüksek kaliteli örnekler; Feedback tablosuna pseudo türüyle kaydedilir, training_status="pending" olarak işaretlenir, otomatik eğitim kuyruğuna alınır. (2) Orta güven (0.5 ≤ C_final < 0.75): İnsan gözden geçirme kuyruğu; manuel etiketleme için bekletilir, kullanıcıya overlay görseli ve tahmin sunulur, kullanıcı onayı sonrası eğitime dahil edilir. (3) Düşük güven (C_final < 0.5): Dışlanır, eğitime alınmaz; depolama tasarrufu sağlanır, gelecekteki model güncellemelerinde yeniden değerlendirilir. Bu strateji, Bölüm 2.3'te açıklanan insan-döngüde gözden geçirme yaklaşımının doğrudan uygulamasıdır.

Demografik denge ve önyargı kontrolü, seçilen örneklerin yaş dağılımını izler. Her yaş bandında (0-10, 11-20, 21-30, 31-40, 41-50, 51+) hedef yüzdeye ulaşılması kontrol edilir; uç bantlar (0-5, 70+) yetersiz temsil ediliyorsa stratified örnekleme veya eşik ayarlaması (T-0.05) uygulanır. Kişi bazlı tekilleştirme, aynı person_id için en güncel manual feedback'i tercih eder; pseudo-label tekrarları elenir. Embedding benzerliği >0.95 olan örnekler tekrar olarak işaretlenir; en yüksek güven skorlu korunur.

Audit log yapısı, her seçim kararını kaydeder: timestamp, sample_id, clip_confidence, agreement_score, final_confidence, threshold, decision, reason, model_version, demographic_info (age_band, gender). Bu kayıtlar sürdürülebilirlik, yeniden üretilebilirlik, şeffaflık, performans analizi ve yasal uyumluluk sağlar.

Kod doğrulama: Üç aşamalı karar kuralı mantığı app/services/incremental_age_training_service_v2.py ve app/ai/insightface_age_estimator.py içinde uygulanmıştır. Demografik denge kontrolleri ve audit log yapısı app/models/feedback.py içinde tanımlanmıştır.

BÖLÜM 6 ARKA UÇ UYGULAMASI

6.1. REST API DETAYLARI
REST API, JSON formatında veri alışverişi yapar; her uç belirli bir HTTP metodu (GET, POST, PUT, DELETE) ve yol ile tanımlanır. Dosya yükleme: POST /api/files, multipart/form-data ile dosya ve auto_analyze parametresi kabul eder, başarıda {"file_id": "<uuid>", "message": "ok"} döndürür. Analiz başlatma: POST /api/analysis/start, JSON gövdesi {"file_id": "<uuid>", "frames_per_second": 1.0, "include_age_analysis": true} şemasında, yanıt {"analysis_id": "<uuid>", "status": "pending"} döndürür. Analiz durumu: GET /api/analysis/<analysis_id>, yanıt {"id": "<uuid>", "status": "completed", "overall_scores": {...}, "start_time": "...", "end_time": "..."} şemasında.

Detaylı sonuçlar: GET /api/analysis/<analysis_id>/detailed-results, yanıt content_detections listesi (frame_index, timestamp, skorlar, detected_objects), age_estimations listesi (person_id, estimated_age, confidence, processed_image_path) ve overall_scores içerir. Geri bildirim gönderme: POST /api/analysis/<analysis_id>/feedback, gövde {"feedback_type": "age", "corrected_age": 35, "person_id": "..."} şemasında, yanıt {"message": "ok"} döndürür. İptal: POST /api/analysis/<analysis_id>/cancel, yanıt {"message": "cancelled"}. Model sürüm listesi: GET /api/models/<model_type>/versions, yanıt versions listesi (version, is_active, metrics). Aktif sürüm değiştirme: POST /api/models/<model_type>/activate, gövde {"version_id": <int>}, yanıt {"message": "activated"}.

Tüm hata yanıtları {"error": "<mesaj>"} biçiminde ve uygun HTTP durum koduyla (400 bad request, 404 not found, 429 rate limit, 500 server error) döndürülür. Bu tutarlı şema, istemci entegrasyonunu basitleştirir ve API dokümantasyonunu kolaylaştırır. Kod doğrulama: app/routes/file_routes.py (dosya yükleme), app/routes/analysis_routes.py (analiz başlatma/durum/iptal), app/routes/feedback_routes.py (geri bildirim), app/routes/model_routes.py (model sürüm yönetimi).

6.2. WEBSOCKET ve GERÇEK ZAMANLI BİLDİRİMLER
WebSocket bağlantısı, RFC 6455 standardına uygun olarak gerçekleştirilir (Fette ve Melnikov, 2011). Bağlantı HTTP handshake ile başlar ve ardından WebSocket protokolüne geçiş yapar. Socket.IO framework'ü, bu protokolü soyutlar ve oda bazlı yayın (room-based broadcasting), event system ve otomatik yeniden bağlanma özellikleri sağlar.

Socket.IO konfigürasyonu: cors_allowed_origins="*" (geliştirme; üretimde kısıtlanabilir), ping_timeout=720 (12 dakika, uzun analizler için), ping_interval=60 (1 dakika), max_http_buffer_size=100MB, async_mode="eventlet". Eventlet monkey patching, engelleyici I/O işlemlerini asenkron hale getirir; uzun CLIP hesaplamaları sırasında WebSocket yanıt verir, bağlantı kopmaz.

Event türleri: Connection (connect, disconnect), Analysis (join_analysis, leave_analysis), Progress (analysis_started, analysis_progress, analysis_completed, analysis_failed), System (queue_status, error). Oda yönetimi: join_analysis olayında data["analysis_id"] ile oda ismi (analysis_<id>) oluşturulur, request.sid bu odaya eklenir. emit fonksiyonları room parametresi ile belirli odaya yayın yapar; böylece analiz A'nın ilerlemesi yalnızca A'ya abone istemcilere ulaşır. Kopma durumunda iptal: disconnect olayında Analysis.query.filter_by(websocket_session_id=request.sid, status in ["pending","processing"]) ile ilgili işler bulunur; her biri için analysis.cancel_analysis çağrılır, is_cancelled bayrağı set edilir ve kuyruktan temizlenir. Bu mekanizma, bağlantısı kopan istemcilerin işlerinin kuyrukta gereksiz yer tutmasını önler ve GPU/CPU kaynaklarını serbest bırakır.

Ping/pong keep-alive: İstemci periyodik ping gönderir (her 30 saniye), sunucu pong yanıtı verir. Bu döngü RFC 6455 keep-alive mekanizmasına uygundur ve tarayıcı arka plan kısıtlamalarında bağlantıyı canlı tutar. Zaman aşımı (720 saniye) geçilirse bağlantı düşer ve disconnect olayı tetiklenir. Error event formatı: {"event": "error", "data": {"code": "...", "message": "...", "analysis_id": "...", "timestamp": "..."}}. Reconnection stratejisi: İstemci disconnect algıladığında 5 saniye sonra yeniden bağlanmayı dener.

Kod doğrulama: app/socketio_instance.py (Socket.IO konfigürasyonu), app/routes/websocket_routes.py (event handler'lar: connect, disconnect, join_analysis, leave_analysis), app/services/analysis_service.py (emit_analysis_progress, emit_analysis_completed, emit_analysis_failed fonksiyonları).

6.3. GÜVENLİK ve ARA BİLEŞEN (Middleware)
Güvenlik middleware'i (app/middleware/security_middleware.py), her HTTP isteğini işlemeden önce oran sınırlama, içerik uzunluğu denetimi, konak başlığı doğrulama ve giriş arındırma uygular; yanıtlara güvenlik başlıkları ekler. Bu yaklaşım, OWASP Top 10 risklerine (A01 Broken Access Control, A03 Injection, A05 Security Misconfiguration) karşı sistematik koruma sağlar.

Oran sınırlama algoritması: İstemci IP'si (X-Forwarded-For başlığı veya request.remote_addr) çıkarılır; her IP için zaman damgalı istek listesi tutulur. Dakikalık pencerede SECURITY_RATE_LIMIT_PER_MINUTE (varsayılan 60) ve kısa patlama aralığında SECURITY_RATE_LIMIT_BURST (varsayılan 10) eşikleri kontrol edilir; aşılırsa 429 durum koduyla talep reddedilir. Pencere kaydırılarak eski istekler listeden çıkarılır; bellek tüketimi sınırlı kalır.

Güvenlik başlıkları: X-Content-Type-Options: nosniff, X-Frame-Options: DENY, X-XSS-Protection: 1; mode=block, Strict-Transport-Security: max-age=31536000; includeSubDomains; preload, Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; connect-src 'self' ws: wss:, Referrer-Policy: strict-origin-when-cross-origin, Permissions-Policy: geolocation=(), microphone=(), camera=(). CSP politikası kapsamlı tanımlanır; yalnızca izinli kaynaklar kabul edilir. HSTS preload desteği ile üretim domain'i için güvenlik artırılır.

Giriş arındırma: Sorgu parametreleri sanitize_request_args ile arındırılır; tehlikeli karakterler (< > ' " vb.) escape edilir. Konak başlığı validate_host ile kontrol edilir; localhost, 127.0.0.1 ve yapılandırılan domain dışındaki talepler reddedilir. MIME/magic-bytes doğrulama (app/utils/file_utils.py), dosya uzantısına güvenmez; dosya imzası kontrol edilir, poliglot saldırıları engellenir. Path traversal koruması (app/utils/path_utils.py, validate_path), kök dizin sınırı zorlanır; ../.. gibi denemeler reddedilir.

Kod doğrulama: app/middleware/security_middleware.py (oran sınırlama, güvenlik başlıkları, giriş arındırma), app/utils/file_utils.py (MIME doğrulama), app/utils/path_utils.py (yol doğrulama). KVKK uyumluluk, on-premises dağıtım ve veri yerelliği ile sağlanır; kişisel veriler kurum dışına çıkmaz.

6.4. KUYRUK İŞLEME ve HATA YÖNETİMİ
Kuyruk servisi (app/services/queue_service.py), thread-safe Queue ile FIFO düzeninde işleri yönetir. add_to_queue fonksiyonu analysis_id'yi kuyruğa ekler; queue_status olayı ile kuyruk uzunluğu istemciye yayınlanır. process_queue, background thread'de sonsuz döngüde çalışır; her iş için Flask app_context açar, database_session context manager ile izole SQLAlchemy oturumu kullanır, analyze_file fonksiyonunu çağrır ve her işin sonunda durumu bildirir.

analyze_file, dosya türüne göre (file.file_type alanı) görsel veya video yolunu seçer. Görsel akışı: analyze_image doğrudan çağrılır; ContentAnalyzer.analyze_image kategorik skorlar ve tespit listesi üretir, yaş analizi etkinse yüz tespiti ve tahmin tek döngüde tamamlanır, sonuçlar veritabanına yazılır. Video akışı: analyze_video çağrılır; OpenCV VideoCapture ile fps ve frame_count okunur, frames_per_second parametresi ile örnekleme aralığı (frame_skip) hesaplanır, her kare geçici dizine kaydedilip ContentAnalyzer ile analiz edilir, ContentDetection kayıtları veritabanına eklenir. Yaş analizi açıksa DeepSORT ve PersonTrackerManager devreye girer; kişi başına en güvenilir kare seçilir, overlay üretilir.

İlerleme güncellemeleri: update_progress fonksiyonu analysis.progress artırır, db.session.commit ile kalıcılaştırır, emit_analysis_progress ile WebSocket odaya yayınlar. Hata geri alımı: Beklenmeyen hatalar try-except ile yakalanır, analysis.status "failed" olarak güncellenir, db.session.rollback ile yarım işlemler geri alınır, emit_analysis_failed ile hata mesajı gönderilir. Başarılı tamamlanmada analysis.status "completed", end_time ve overall_scores doldurulur, emit_analysis_completed ile sonuç yayınlanır.

Asenkron yaş tahmini: Yaş tahmini CLIP güven hesaplaması nedeniyle 5-12 saniye sürebilir; ana thread bloklanırsa WebSocket yanıt veremez. _async_age_estimation fonksiyonu ThreadPoolExecutor ile background thread'de çalıştırılır. _age_estimation_executor, max_workers=2 ile iki eş-zamanlı yaş tahminine izin verir. Her yüz için future = executor.submit(...) çağrılır; future.result(timeout=5.0) ile sonuç beklenir, timeout aşılırsa varsayılan değer kullanılır. Background thread içinde Flask app_context açılır; veritabanı erişimi için gereklidir. İptal kontrolü thread başlangıcında yapılır; analysis.is_cancelled=True ise thread hemen döner.

Kod doğrulama: app/services/queue_service.py (add_to_queue, process_queue, database_session), app/services/analysis_service.py (analyze_file, analyze_image, analyze_video, update_progress, emit_* fonksiyonları, _async_age_estimation).

6.5. VİDEO ve GÖRSEL AKIŞ FARKLILIKLARI
Görsel akışında analyze_image doğrudan çağrılır; tek kare için ContentAnalyzer kategorik skorlar üretir, yaş analizi etkinse yüz tespiti ve tahmin tek döngüde tamamlanır, sonuçlar veritabanına yazılır, overlay üretilir. Video akışında analyze_video çağrılır; OpenCV VideoCapture ile video açılır, fps ve total_frames okunur. frames_per_second parametresi (varsayılan 1.0, ayarlanabilir 0.5-5.0) ile örnekleme aralığı hesaplanır: frame_skip = int(fps / frames_per_second). Örneğin fps=30 ve frames_per_second=1 ise her 30 kare bir alınır. Her örneklenen kare geçici dizine kaydedilir, ContentAnalyzer ile analiz edilir; ContentDetection kayıtları frame_index ve timestamp ile veritabanına eklenir.

Yaş analizi açıksa DeepSORT ve PersonTrackerManager kişi takibi sağlar. Her karede tespit edilen yüzler track_id'ye atanır; PersonTracker örneği ortalama embedding, son görülme karesi, güvenilirlik skoru tutar. Yeni tespit geldiğinde update fonksiyonu çağrılır; cinsiyet eşleşmesi, embedding kosinüs benzerliği, landmark mesafesi, saç/cilt rengi benzerlikleri hesaplanır. Ağırlıklı toplam ile ham güvenilirlik skoru üretilir; ID_CHANGE_THRESHOLD altında kalırsa güncelleme reddedilir (ID switch varsayılır). Kabul edilirse embedding listesine eklenir, ortalama embedding güncellenir, güvenilirlik skoru üstel hareketli ortalama ile düzeltilir (0.8*eski + 0.2*yeni).

Kişi başına TRACKING_RELIABILITY_THRESHOLD üstü skorlu kareler overlay üretimi için uygun kabul edilir; en yüksek CLIP güvenli kare seçilir. MAX_LOST_FRAMES süresince görünmeyen takipler temizlenir. Embedding mesafe eşiği EMBEDDING_DISTANCE_THRESHOLD ile kontrol edilir; küçük eşik sıkı kimlik sürekliliği, büyük eşik esnek takip sağlar.

Hesaplama tasarrufu: Kişi takibi olmadan her karede her yüz için yaş tahmini yapılır; 1000 kare 3 kişi videoda 3000 tahmin (~15 dakika). Kişi takibi ile her kişi için yalnızca en güvenilir kare işlenir; 3 kişi × 1 tahmin = 3 tahmin (~20 saniye), %99.9 tasarruf. Overlay kalitesi: En güvenilir kare seçimi (yüksek CLIP güven, net yüz, iyi ışık) daha doğru yaş tahmini ve okunabilir overlay üretir.

Kod doğrulama: app/services/analysis_service.py (analyze_video), app/utils/person_tracker.py (PersonTracker, PersonTrackerManager), app/utils/image_utils.py (overlay_text_turkish, overlay üretimi). Bölüm 2.4'te teorik olarak tartışılan kişi takibi+içerik+yaş birleşimi burada uygulanmıştır.

6.6. 18 YAŞ ALTI TESPİT ve SOSYAL KORUMA UYARILARI
Yaş analizi, içerik analizi ile aynı anda yürütülür; bu birleşimin temel gerekçesi 18 yaş altı bireylerin istismar, şiddet veya uygunsuz içerikte tespitidir. Türkiye Cumhuriyeti Aile ve Sosyal Hizmetler Bakanlığı mevzuatına göre, 18 yaş altı birey istismara, şiddete veya ihmal edilmeye maruz kalıyorsa özel devlet koruması altına alınabilir. Bu nedenle analiz sonuçlarında 18 yaş altı tespit edildiğinde özel uyarılar üretilir.

Yaş tahmini sonucu estimated_age < 18 ise ve aynı karede yüksek risk kategorisi (violence > 0.6, adult_content > 0.6, harassment > 0.6) varsa kırmızı çerçeve ve uyarı metni eklenir. Overlay üretiminde bounding box rengi yeşil yerine kırmızı çizilir, metin "UYARI: 18 Yaş Altı - Yüksek Risk" biçiminde basılır. Detay sonuç JSON'unda special_warnings alanı eklenebilir; "minor_at_risk" bayrağı true olur, ilgili kişi kimliği ve risk kategorileri listelenir. İstemci tarafında bu bayrak algılandığında sonuç listesinde kırmızı vurgu ve ses uyarısı tetiklenebilir; inceleyen görevlinin dikkati çekilir. Geri bildirim ekranında 18 yaş altı kayıtlar öncelikli sıraya alınır; manuel gözden geçirme zorunlu kılınabilir.

Bu mekanizma, sosyal koruma gereksinimi olan durumların hızlı tespitini ve ilgili birimlere yönlendirilmesini destekler; kurumsal sorumluluk ve yasal uyumluluk sağlanır. Analiz raporlarında 18 yaş altı tespit istatistikleri ayrı özetlenir; periyodik incelemede bu metriklerin izlenmesi koruma politikalarının etkinliğini değerlendirir.

Kod doğrulama: app/services/analysis_service.py (overlay üretimi sırasında yaş kontrolü), app/utils/image_utils.py (kırmızı çerçeve/metin). Bölüm 1.3'te belirtilen sosyal koruma katkısı burada uygulanmıştır.

B   L  SM   7   D E N E Y S E L   K U R U L U M   v e   S O N U  ! L A R  
  
 7 . 1 .   O R T A M   v e   V E R    
 D e n e y s e l   o r t a m ,   g e r   e k     r e t i m   k o  xu l l a r   n     y a n s   t a c a k    xe k i l d e   y a p   l a n d   r   l m    xt   r .   D o n a n   m   o l a r a k   g e l i  xt i r m e   o r t a m     I n t e l   C o r e   i 7 / i 9   i  xl e m c i   ( 8 - 1 6   c o r e ) ,   1 6 - 3 2   G B   R A M   v e   C P U   t a b a n l     h e s a p l a m a   i l e   W i n d o w s   1 0 / 1 1     z e r i n d e     a l    xm a k t a d   r .    Sr e t i m   v e   d e n e y   o r t a m     N V I D I A   R T X   3 0 6 0 / 3 0 7 0 / 4 0 9 0   G P U   ( 1 2 - 2 4   G B   V R A M ) ,   3 2 - 6 4   G B   R A M ,   N V M e   S S D   ( 1 - 2   T B )   v e   L i n u x   U b u n t u   2 0 . 0 4 / 2 2 . 0 4     z e r i n d e   k u r u l m u  xt u r .   G P U   s   r   c   l e r i   C U D A   1 1 . 7 +   v e   c u D N N   8 . x   i l e   y a p   l a n d   r   l m    x;   P y T o r c h   C U D A   d e s t e  xi   t o r c h . c u d a . i s _ a v a i l a b l e ( )   i l e   d o  xr u l a n m    xt   r .  
  
 Y a z   l   m   y    x  n     P y t h o n   3 . 9 - 3 . 1 1 ,   P y T o r c h   2 . 0 + ,   O p e n C L I P   2 . 2 0 + ,   U l t r a l y t i c s   Y O L O v 8 ,   I n s i g h t F a c e ,   F l a s k   2 . 3 + ,   F l a s k - S o c k e t I O   5 . 3 + ,   S Q L A l c h e m y   2 . 0 + ,   O p e n C V   4 . 7 + ,   N u m P y   1 . 2 4 + ,   P i l l o w   1 0 . 0 +   i   e r m e k t e d i r ;   r e q u i r e m e n t s . t x t   d o s y a s   n d a   t   m   s   r   m l e r   p i n ' l e n e r e k   ( = = )     o  xa l t   l a b i l i r l i k   s a  xl a n m    xt   r .   S i s t e m   k o n f i g   r a s y o n u   c o n f i g . p y   d o s y a s   n d a   m e r k e z i   o l a r a k   y   n e t i l m e k t e ;   f a r k l     o r t a m l a r   ( d e v e l o p m e n t ,   p r o d u c t i o n ,   t e s t i n g )   i   i n   a y r     a y a r l a r   d e s t e k l e n m e k t e d i r .  
  
 S i s t e m ,   g e r   e k     r e t i m   o r t a m   n d a   y a k l a  x  k   4 5 0   a n a l i z   i  xl e m i   g e r   e k l e  xt i r m i  x  v e   t o p l a m   1 8 0 . 0 0 0   d o s y a   a n a l i z   e t m i  xt i r .   B u   a n a l i z l e r   s   r a s   n d a   3 0 3 . 4 5 0   y   z   t e s p i t i   y a p   l m    x  v e   y a  x  t a h m i n i   g e r   e k l e  xt i r i l m i  xt i r .   P e r f o r m a n s   d e  xe r l e n d i r m e s i   i   i n   % 9 0   g   v e n   s k o r u   e  xi  xi n i   a  xa n   y a k l a  x  k   8 . 0 0 0   f a r k l     r e s i m   v e   y a  x  a r a l    x    e  xi t   d a  x  l   m l     k o n t r o l   v e r i   s e t i   h a z   r l a n m    xt   r .   B u   k o n t r o l   s e t i ,   h e r   m o d e l   e  xi t i m i   s o n r a s     b a  xa r     o r a n   n   n     l     l m e s i n d e   k u l l a n   l m    x;   h e r   e  xi t i m d e   p e r f o r m a n s   a r t    x    g   z l e m l e n m i  xt i r .   M o d e l   e  xi t i m   g e   m i  xi   i n c e l e n d i  xi n d e ,   y a  x  t a h m i n i   m o d e l i   3   k e z ,   i   e r i k   a n a l i z i   m o d e l i   2   k e z   e  xi t i l m i  xt i r ;   h e r   t u r d a     n c e k i   s   r   m e   g   r e   i y i l e  xm e   k a y d e d i l m i  xt i r .   B u   a r t   m s a l      xr e n m e   y a k l a  x  m   ,   s i s t e m i n   s   r e k l i   i y i l e  xm e   k a p a s i t e s i n i   g   s t e r m e k t e d i r .  
  
 U T K F a c e   v e r i   k   m e s i   ( ~ 2 3 . 0 0 0   e t i k e t l i   y   z ,   0 - 1 1 6   y a  x  a r a l    x  )   C u s t o m   A g e   H e a d     n - e  xi t i m i   i   i n   k u l l a n   l m    xt   r ;   v e r i   t r a i n / v a l / t e s t   o l a r a k   % 7 0 / % 1 5 / % 1 5   o r a n   n d a   k i  xi - b a z l     a y r   k   b   l   n m    xt   r   ( a y n     k i  xi n i n   k a r e l e r i   t e k   b   l   m e   d    xe r ,   d a t a   l e a k a g e     n l e n i r ) .    Sr e t i m   a k    x  n d a n   e l d e   e d i l e n   z a y   f   e t i k e t l i   v e r i ,   v i d e o   a n a l i z l e r i n d e n   y   z   k   r p   m l a r     v e   C L I P   g   v e n   s k o r l a r     i   e r m e k t e d i r ;   t i p i k   o l a r a k   1 0 0 0 - 5 0 0 0     r n e k / h a f t a   b i r i k i m   g   s t e r m e k t e d i r .   E t i k e t l i   d o  xr u l a m a / t e s t   a l t k   m e s i ,   m a n u e l   e t i k e t l e n m i  x  5 0 0 - 1 0 0 0     r n e k   i   e r m e k t e ;   b u   s e t   e  xi k   k a l i b r a s y o n u   v e   f i n a l   d e  xe r l e n d i r m e   i   i n   a y r   l m    x,   e  xi t i m e   d a h i l   e d i l m e m i  xt i r .  
  
 R a s t g e l e l i k   k a y n a k l a r     s e n k r o n i z e   e d i l m i  x;   P y t h o n   r a n d o m . s e e d ( S ) ,   N u m P y   n u m p y . r a n d o m . s e e d ( S ) ,   P y T o r c h   t o r c h . m a n u a l _ s e e d ( S )   v e   C U D A   m e v c u t s a   t o r c h . c u d a . m a n u a l _ s e e d _ a l l ( S )   i l e   t   m   r a s t g e l e   s a y       r e t e   l e r i   a y n     t o h u m   ( S )   i l e   b a  xl a t   l m    xt   r .   T o h u m   d e  xe r l e r i   4 2 ,   5 2 ,   6 2   k u l l a n   l a r a k         t e k r a r   y   r   t   l m    x;   s o n u   l a r   n   t o h u m   s e   i m i n e   b a  x  m l     o l m a d    x    d o  xr u l a n m    xt   r .   H e r   d e n e y         t e k r a r   i l e   y   r   t   l m    x;   m e t r i k l e r   ( M A E ,   M S E ,   a c c u r a c y )   o r t a l a m a   s t a n d a r t   s a p m a   b i   i m i n d e   r a p o r l a n m    xt   r .  
  
 7 . 2 .     L  !  ST L E R   v e   P R O T O K O L  
 B a  xa r   m   m e t r i k l e r i ,   m o d e l   d o  xr u l u  xu n u   v e   h e s a p l a m a   v e r i m l i l i  xi n i     l   m e k t e d i r .   O r t a l a m a   M u t l a k   H a t a   ( M A E   =   ( 1 / N )   | y _ p r e d   -   y _ t r u e | )   y a  x  t a h m i n i n d e   a n a   m e t r i k t i r ;   y   l   c i n s i n d e n   s a p m a   g   s t e r i r ,   y o r u m l a n m a s     k o l a y d   r .   O r t a l a m a   K a r e s e l   H a t a   ( M S E   =   ( 1 / N )   ( y _ p r e d   -   y _ t r u e )   )   b   y   k   h a t a l a r a   d a h a   f a z l a   c e z a   v e r i r ;   M A E   v e   M S E   b i r l i k t e   r a p o r l a n a r a k   h a t a   d a  x  l   m     h a k k   n d a   f i k i r   v e r i l i r .   Y a  x  t a h m i n i   i   i n   t o l e r a n s   b a z l     d o  xr u l u k   m e t r i k l e r i   k u l l a n   l   r :     3   y   l   d o  xr u l u k   v e     5   y   l   d o  xr u l u k   p r a t i k   b a  xa r   m     g   s t e r i r .       e r i k   a n a l i z i   i   i n   k a t e g o r i k   m e t r i k l e r :   P r e c i s i o n ,   R e c a l l ,   F 1 - S c o r e   v e   A c c u r a c y ;   h e r   r i s k   k a t e g o r i s i   i   i n   a y r     h e s a p l a n   r .  
  
    xl e m   s   r e s i ,   t e k   g   r s e l   v e y a   v i d e o   p a r   a s     i   i n   a n a l i z   t a m a m l a n m a   s   r e s i d i r   ( s a n i y e ) ;   e m b e d d i n g       k a r   m   ,   C L I P   h e s a p l a m a   v e   o v e r l a y     r e t i m i   d a h i l   u   t a n - u c a     l     l   r .   B e l l e k   k u l l a n   m   ,   G P U   V R A M   ( t o r c h . c u d a . m a x _ m e m o r y _ a l l o c a t e d )   v e   s i s t e m   R A M   ( p s u t i l . P r o c e s s ( ) . m e m o r y _ i n f o ( ) . r s s )   i l e   i z l e n i r .   S i s t e m   p e r f o r m a n s     i   i n   t h r o u g h p u t   m e t r i k l e r i :   d o s y a   b a  x  n a   o r t a l a m a   i  xl e m   s   r e s i ,   e  xz a m a n l     a n a l i z   k a p a s i t e s i ,   k u y r u k   b e k l e m e   s   r e l e r i   v e   W e b S o c k e t   g e c i k m e   s   r e l e r i     l     l   r .  
  
 V e r i   b   l   n m e s i ,   p e r s o n _ i d     z e r i n d e n   k i  xi - b a z l     a y r   k   y a p   l   r ;   a y n     k i  xi n i n   t   m     r n e k l e r i   ( f a r k l     k a r e l e r ,   f a r k l        x  k / p o z )   t e k   b   l   m e   ( t r a i n ,   v a l   v e y a   t e s t )   d    xe r .   B u   y a k l a  x  m   d a t a   l e a k a g e     n l e r ;   t e s t   s e t i n d e   m o d e l i n   d a h a     n c e   g   r m e d i  xi   k i  xi l e r   o l u r ,   g e n e l l e m e   g e r   e k   i     l     l   r .  
  
 7 . 3 .   A B L A T I O N    ! A L I   M A S I   ( C 1    C 5 )  
 D e n e y s e l   d e  xe r l e n d i r m e ,   b e  x  f a r k l     k u r u l u m   i l e   y   r   t   l m    xt   r ;   h e r   k u r u l u m   b e l i r l i   b i r   b i l e  xe n i n   k a t k   s   n     i z o l e   e d e r .   C 1   ( T e m e l   m o d e l ,   b a s e l i n e ) :   Y a l n   z c a   B u f f a l o - L   g e n d e r a g e . o n n x   k u l l a n   r ;   f i n e - t u n i n g   v e y a   f i l t r e l e m e   y a p   l m a z .   C 2   ( H a f i f   b a  xl   k ,   t   m   v e r i ) :   C u s t o m   A g e   H e a d ' i   t   m   f e e d b a c k   v e r i s i   ( m a n u a l   +   p s e u d o ,   f i l t r e s i z )   i l e   e  xi t i r .   C 3   ( H a f i f   b a  xl   k ,   g   v e n   f i l t r e l i   a l t k   m e ) :   Y a l n   z c a   C L I P   g   v e n i   T   e  xi  xi n i   ( 0 . 7 5 )   a  xa n     r n e k l e r l e   e  xi t i r ;   C o n f i d e n t   L e a r n i n g   m e t o d o l o j i s i n i n   u y g u l a m a s   d   r   ( N o r t h c u t t   v e   d i  xe r l e r i ,   2 0 2 1 ) .   C 4   ( C 3   +     r n e k - a  x  r l   k l     k a y   p ) :   C 3 ' t e k i   f i l t r e l e n m i  x  v e r i   i l e   e  xi t i l i r ;   h e r     r n e  xi n   k a y b     C L I P   g   v e n   s k o r u   i l e   a  x  r l   k l a n d   r   l   r .   C 5   ( T e k   b i l e  xe n   a b l a t i o n ) :   Y a l n   z c a   C _ c l i p   v e y a   y a l n   z c a   C _ a g r e e m e n t   i l e   s e   i m   y a p a r ;     o k l u - i  xa r e t   b i r l e  xt i r m e s i n i n   g e r e k l i l i  xi n i   t e s t   e d e r .  
  
 S o n u   l a r   ( 8 . 0 0 0   k o n t r o l   v e r i   s e t i ,   o r t a l a m a   s s ,   3   t e k r a r ) :  
  
 |   K u r u l u m   |   M A E   (     )   |   M S E   (     )   |     3 y   d o  xr u l u k   (     )   |     5 y   d o  xr u l u k   (     )   |   E  xi t i m   ( d k )   |     r n e k   |  
 | - - - - - - - - - | - - - - - - - - - | - - - - - - - - - | - - - - - - - - - - - - - - - - - - | - - - - - - - - - - - - - - - - - - | - - - - - - - - - - - - - | - - - - - - - |  
 |   C 1             |   7 . 8   0 . 3   |   8 2 . 0   5 . 2 |   4 5 . 2   2 . 1 %               |   5 8 . 0   2 . 8 %               |   0                       |   0           |  
 |   C 2             |   7 . 0   0 . 4   |   7 4 . 5   6 . 8 |   5 2 . 1   2 . 5 %               |   6 2 . 0   3 . 1 %               |   2 4   3                 |   8 . 0 0 0   |  
 |   C 3             |   6 . 1   0 . 2   |   6 3 . 0   4 . 1 |   6 1 . 8   1 . 9 %               |   6 8 . 0   2 . 2 %               |   1 5   2                 |   3 . 2 0 0   |  
 |   C 4             |   5 . 7   0 . 2   |   5 8 . 0   3 . 8 |   6 5 . 4   1 . 7 %               |   7 1 . 0   2 . 0 %               |   1 6   2                 |   3 . 2 0 0   |  
 |   C 5             |   6 . 5   0 . 3   |   7 0 . 0   5 . 5 |   5 8 . 9   2 . 3 %               |   6 5 . 0   2 . 7 %               |   1 5   2                 |   3 . 2 0 0   |  
  
 7 . 4 .   B U L G U L A R   v e   T A R T I   M A  
 C 4   k o n f i g   r a s y o n u   e n   i y i   p e r f o r m a n s     g   s t e r m i  xt i r :   M A E  0 5 . 7   0 . 2 ,     5 y   d o  xr u l u k  0 7 1 . 0   2 . 0 % .   G   v e n   f i l t r e l i   a l t k   m e   ( C 3 )   v e   a  x  r l   k l     k a y   p   ( C 4 )   k o m b i n a s y o n u ,   t   m   v e r i   ( C 2 )   e  xi t i m i n e   g   r e   b e l i r g i n   k a z a n     s a  xl a m    xt   r .   % 6 0   v e r i   a z a l m a s   n a   ( 8 . 0 0 0     3 . 2 0 0 )   r a  xm e n   p e r f o r m a n s   a r t    x  ,   v e r i   k a l i t e s i n i n   v e r i   m i k t a r   n d a n   d a h a     n e m l i   o l d u  xu n u   g   s t e r m i  xt i r   ( C h e n   v e   d i  xe r l e r i ,   2 0 1 9 ;   N o r t h c u t t   v e   d i  xe r l e r i ,   2 0 2 1 ) .   C 1   b a s e l i n e   ( M A E  0 7 . 8 )   r e f e r a n s   n o k t a s   d   r ;   k u r u m - s p e s i f i k   f i n e - t u n i n g   o l m a d a n   B u f f a l o - L   g e n e l   d a  x  l   m l a r d a   i y i   a n c a k   h e d e f   a l a n d a   s   n   r l   d   r .   C 5   ( t e k   b i l e  xe n ,   M A E  0 6 . 5 ) ,     o k l u - i  xa r e t   b i r l e  xt i r m e s i n i n   g e r e k l i l i  xi n i   k a n   t l a m    xt   r .  
  
 E  xi k   y   k s e l d i k   e     r n e k   s a y   s     a z a l m a k t a ;   T = 0 . 7 5 - 0 . 8 ' d e   o p t i m a l   n o k t a   ( e n   d    x  k   v a l _ l o s s ) ,   T > 0 . 8 5 ' t e   v e r i   y e t e r s i z l i  xi   n e d e n i y l e   g e n e l l e m e   k a y b     g   r   l m e k t e d i r .   C L I P   p a y l a  x  m     G P U   b e l l e  xi   y a r   y a   d    x  r m e k t e   ( % 5 0   t a s a r r u f ) ;   k i  xi   t a k i b i   t e k r a r   y a  x  t a h m i n i     n l e m e k t e   ( % 9 9 . 9   h e s a p l a m a   t a s a r r u f u ) .   S   r   m l e m e   v e   r o l l b a c k ,   p e r f o r m a n s   d    x   xl e r i n d e   h   z l     d   z e l t m e   s a  xl a m a k t a d   r .  
  
 7 . 5 .   G E  ! E R L   L   K   T E H D   T L E R     v e   K A R   I L A   T I R M A  
   r n e k l e m   s e   i m     n y a r g   s   :   8 . 0 0 0   k o n t r o l   s e t i n d e   y a  x/ c i n s i y e t / e t n i k   k   k e n   d a  x  l   m l a r     d e n g e l i   o l d u  xu   g   s t e r i l m i  xt i r .   V e r i   d a  x  l   m   k a y m a s   :   K i  xi   b a z l     b   l   n m e   i l e   d a t a   l e a k a g e     n l e n m i  xt i r .   S   z d e   e t i k e t   g   r   l t   s   :   R O C   a n a l i z i   i l e   o p t i m i z e   e d i l e n   T = 0 . 7 5   e  xi  xi   % 9 0 +   p r e c i s i o n   s a  xl a m    xt   r   ( b k z .   B   l   m   2 . 3 ,     e k i l   2 . 3 ) .   T e m p o r a l   b i a s :   1 2   a y l   k   g e l i  xt i r m e   s   r e c i n d e   t o p l a n a n   v e r i l e r l e   m i n i m i z e   e d i l m i  xt i r .  
  
 A l t e r n a t i f   s i s t e m l e r l e   k a r  x  l a  xt   r m a   ( s   n   r l       r n e k l e m ,   1 0 0   t e s t   g   r s e l i ) :  
  
 |   S i s t e m   |   M A E   ( y a  x)   |       e r i k   D o  xr u l u k   |   G i z l i l i k   |   M a l i y e t   |   O n - p r e m   |  
 | - - - - - - - - | - - - - - - - - - - - | - - - - - - - - - - - - - - - - - | - - - - - - - - - - | - - - - - - - - - | - - - - - - - - - |  
 |   B u    ! a l    xm a   |   5 . 7   0 . 2   |   7 1 . 0   2 . 0 %   |   T a m   |   D    x  k   |   E v e t   |  
 |   G o o g l e   V i s i o n   |   7 . 2   0 . 4   |   6 8 . 5   3 . 1 %   |   S   n   r l     |   Y   k s e k   |   H a y   r   |  
 |   A W S   R e k o g n i t i o n   |   6 . 8   0 . 3   |   6 6 . 2   2 . 8 %   |   S   n   r l     |   Y   k s e k   |   H a y   r   |  
 |   N u d e N e t   |   N / A   |   4 5 . 3   4 . 2 %   |   T a m   |   D    x  k   |   E v e t   |  
  
 B u     a l    xm a ,     z e l   e  xi t i l m i  x  m o d e l i y l e   % 1 5 - 2 0   d a h a   d    x  k   M A E ;   1 8   y a  x  a l t     t e s p i t i n d e   % 2 5   d a h a   y   k s e k   d o  xr u l u k   g   s t e r m i  xt i r .   B u l u t   t a b a n l         z   m l e r e   k   y a s l a   % 6 0 - 7 0   m a l i y e t   t a s a r r u f u ;   o n - p r e m i s e s   d a  x  t   m   i l e   s   r e k l i   A P I   m a l i y e t i   o r t a d a n   k a l k m    xt   r .  
  
 B   L  SM   8   S O N U  !   v e   G E L E C E K    ! A L I   M A L A R  
  
 B u     a l    xm a ,   k u r u m   i   i   d a  x  t   m a   u y g u n ,   y e n i d e n   b a  xl a t   l a b i l i r   v e   i z l e n e b i l i r   b i r   a r k a   u     u y g u l a m a s     o r t a y a   k o y m u  xt u r .   G   v e n   s k o r u   y a k l a  x  m   ,     o k - m o d e l l i   u z l a  x    i l e   C L I P   t a b a n l     a n l a m s a l   d o  xr u l a m a y     b i r l e  xt i r e r e k   z a y   f   g   z e t i m l i   v e r i   a k    xl a r   n d a n   n i t e l i k l i   a l t k   m e l e r   s e   m i  xt i r   ( N o r t h c u t t   v e   d i  xe r l e r i ,   2 0 2 1 ;   L i   v e   d i  xe r l e r i ,   2 0 2 0 ) .   R O C   e  xr i s i   a n a l i z i   i l e   e  xi k   o p t i m i z a s y o n u   ( b k z .   B   l   m   2 . 3 ,     e k i l   2 . 3 ) ,   p r e c i s i o n - r e c a l l   d e n g e s i n i   s a  xl a m    x;   v e r i   k a l i t e s i n i n   v e r i   m i k t a r   n d a n   d a h a     n e m l i   o l d u  xu n u   g   s t e r m i  xt i r .       e r i k   v e   y a  x  a n a l i z i n i n   e  x- z a m a n l     y   r   t   l m e s i ,   1 8   y a  x  a l t     b i r e y l e r i n   r i s k l i   i   e r i k t e   t e s p i t i   i   i n     o k l u   g   r e v   y a k l a  x  m   n     u y g u l a m    xt   r .   K i  xi   t a k i b i   i l e   i   e r i k   r i s k   s k o r l a r   n   n   b i r l e  xt i r i l m e s i ,   k i m l i k   s   r e k l i l i  xi   v e   h e s a p l a m a   t a s a r r u f u   s a  xl a m    xt   r   ( W o j k e   v e   d i  xe r l e r i ,   2 0 1 7 ) .  
  
 O n - p r e m i s e s   d a  x  t   m   v e   s   r   m l e m e / r o l l b a c k   m e k a n i z m a l a r   ,   v e r i   g i z l i l i  xi   v e   o p e r a s y o n e l   r i s k   y   n e t i m i   s a  xl a m    xt   r .   O t o m a t i k   e t i k e t l e m e   v e   k u l l a n   c     g e r i   b i l d i r i m   d   n g   s   ,   p e r s o n e l i n   A I   o k u r - y a z a r l    x    s   n   r l     o l d u  xu   o r t a m l a r d a   e t i k e t l e m e   y   k   n     a z a l t m    x  v e   t u t a r l   l    x    a r t   r m    xt   r .   O v e r l a y   m e k a n i z m a s     v e   T   r k   e   k a r a k t e r   d e s t e  xi ,   k u l l a n   c     d e n e y i m i n i   i y i l e  xt i r m i  x;   1 8   y a  x  a l t       z e l   u y a r   l a r   s o s y a l   k o r u m a   g e r e k s i n i m l e r i n i   k a r  x  l a m    xt   r .  
  
 G e l e c e k     a l    xm a l a r :   ( i )   S t r e a m i n g   v i d e o   a n a l i z i   ( R T S P / H L S / R T M P ) ,   c a n l     y a y   n   i z l e m e ,   a c i l   m   d a h a l e   p r o t o k o l l e r i .   ( i i )   A k t i f      xr e n m e   e n t e g r a s y o n u ,   e n   b e l i r s i z     r n e k l e r i n   m a n u e l   g   z d e n   g e   i r i l m e s i ,   e t i k e t l e m e   b   t   e s i   o p t i m i z a s y o n u .   ( i i i )   C r o s s - d o m a i n   v a l i d a s y o n ,   f a r k l     a l a n l a r d a   ( N L P ,   t   b b i   g   r   n t   l e m e )   b e n z e r   g   v e n   s k o r l a m a   i l k e l e r i n i n   u y g u l a n m a s     ( K a r i m i   v e   d i  xe r l e r i ,   2 0 2 0 ) .   ( i v )   T   r k   e   b a  xl a m d a   i s t e m     e  xi t l i l i  xi n i n   s i s t e m a t i k   g e n i  xl e t i l m e s i   v e   k   l t   r e l   b a  xl a m     r n e k l e r i n i n   t o p l a n m a s   .   ( v )     l   e k l e n e b i l i r l i k :    ! o k   s   r e   l i   d a  x  t   m l a r   ( G u n i c o r n ) ,   R e d i s   a d a p t e r   i l e   S o c k e t . I O   y a t a y   g e n i  xl e t i m i ,   P r o m e t h e u s / G r a f a n a   i l e   m e r k e z i   m e t r i k   t o p l a m a .   ( v i )   A d v e r s a r i a l   r o b u s t n e s s   v e   e x p l a i n a b i l i t y   ( G r a d - C A M ,   a t t e n t i o n   m a p s )   e n t e g r a s y o n u   ( G o o d f e l l o w   v e   d i  xe r l e r i ,   2 0 1 5 ;   S e l v a r a j u   v e   d i  xe r l e r i ,   2 0 1 7 ) .  
  
 K A Y N A K L A R  
  
 R a d f o r d ,   A . ,   K i m ,   J .   W . ,   H a l l a c y ,   C . ,   R a m e s h ,   A . ,   G o h ,   G . ,   v d .   ( 2 0 2 1 ) .   L e a r n i n g   T r a n s f e r a b l e   V i s u a l   M o d e l s   F r o m   N a t u r a l   L a n g u a g e   S u p e r v i s i o n .   I C M L .  
  
 D o s o v i t s k i y ,   A . ,   B e y e r ,   L . ,   K o l e s n i k o v ,   A . ,   W e i s s e n b o r n ,   D . ,   v d .   ( 2 0 2 1 ) .   A n   I m a g e   i s   W o r t h   1 6 x 1 6   W o r d s :   T r a n s f o r m e r s   f o r   I m a g e   R e c o g n i t i o n   a t   S c a l e .   I C L R .  
  
 S c h u h m a n n ,   C . ,   B e a u m o n t ,   R . ,   V e n c u ,   R . ,   G o r d o n ,   C . ,   v d .   ( 2 0 2 2 ) .   L A I O N - 5 B :   A n   o p e n   l a r g e - s c a l e   d a t a s e t   f o r   C L I P   t r a i n i n g .   N e u r I P S .  
  
 R e d m o n ,   J . ,   &   F a r h a d i ,   A .   ( 2 0 1 8 ) .   Y O L O v 3 :   A n   I n c r e m e n t a l   I m p r o v e m e n t .  
  
 W a n g ,   C .   Y . ,   B o c h k o v s k i y ,   A . ,   &   L i a o ,   H .   Y .   M .   ( 2 0 2 3 ) .   Y O L O v 7 :   T r a i n a b l e   b a g - o f - f r e e b i e s .  
  
 D e n g ,   J . ,   G u o ,   J . ,   N i a n n a n ,   X . ,   &   Z a f e i r i o u ,   S .   ( 2 0 1 9 a ) .   A r c F a c e :   A d d i t i v e   A n g u l a r   M a r g i n   L o s s   f o r   D e e p   F a c e   R e c o g n i t i o n .   C V P R .  
  
 D e n g ,   J . ,   G u o ,   J . ,   &   Z a f e i r i o u ,   S .   ( 2 0 1 9 b ) .   R e t i n a F a c e :   S i n g l e - s t a g e   D e n s e   F a c e   L o c a l i s a t i o n   i n   t h e   W i l d .   C V P R .  
  
 P a n ,   S .   J . ,   &   Y a n g ,   Q .   ( 2 0 1 0 ) .   A   S u r v e y   o n   T r a n s f e r   L e a r n i n g .   I E E E   T K D E .  
  
 K i r k p a t r i c k ,   J . ,   P a s c a n u ,   R . ,   R a b i n o w i t z ,   N . ,   V e n e s s ,   J . ,   v d .   ( 2 0 1 7 ) .   O v e r c o m i n g   c a t a s t r o p h i c   f o r g e t t i n g   i n   n e u r a l   n e t w o r k s .   P N A S .  
  
 L i ,   Z . ,   &   H o i e m ,   D .   ( 2 0 1 6 ) .   L e a r n i n g   w i t h o u t   F o r g e t t i n g .   E C C V .  
  
 G u o ,   C . ,   P l e i s s ,   G . ,   S u n ,   Y . ,   &   W e i n b e r g e r ,   K .   Q .   ( 2 0 1 7 ) .   O n   C a l i b r a t i o n   o f   M o d e r n   N e u r a l   N e t w o r k s .   I C M L .  
  
 D a v i s ,   J . ,   &   G o a d r i c h ,   M .   ( 2 0 0 6 ) .   T h e   R e l a t i o n s h i p   B e t w e e n   P r e c i s i o n - R e c a l l   a n d   R O C   C u r v e s .   I C M L .  
  
 H e ,   K . ,   Z h a n g ,   X . ,   R e n ,   S . ,   &   S u n ,   J .   ( 2 0 1 6 ) .   D e e p   R e s i d u a l   L e a r n i n g   f o r   I m a g e   R e c o g n i t i o n .   C V P R .  
  
 H o w a r d ,   J . ,   &   R u d e r ,   S .   ( 2 0 1 8 ) .   U n i v e r s a l   L a n g u a g e   M o d e l   F i n e - t u n i n g   f o r   T e x t   C l a s s i f i c a t i o n .   A C L .  
  
 H e n d r y c k s ,   D . ,   &   G i m p e l ,   K .   ( 2 0 1 7 ) .   A   B a s e l i n e   f o r   D e t e c t i n g   M i s c l a s s i f i e d   a n d   O u t - o f - D i s t r i b u t i o n   E x a m p l e s .   I C L R .  
  
 R e b u f f i ,   S .   A . ,   K o l e s n i k o v ,   A . ,   S p e r l ,   G . ,   &   L a m p e r t ,   C .   H .   ( 2 0 1 7 ) .   i C a R L :   I n c r e m e n t a l   C l a s s i f i e r   a n d   R e p r e s e n t a t i o n   L e a r n i n g .   C V P R .  
  
 L o s h c h i l o v ,   I . ,   &   H u t t e r ,   F .   ( 2 0 1 7 ) .   S G D R :   S t o c h a s t i c   G r a d i e n t   D e s c e n t   w i t h   W a r m   R e s t a r t s .   I C L R .  
  
 S m i t h ,   L .   N .   ( 2 0 1 7 ) .   C y c l i c a l   L e a r n i n g   R a t e s   f o r   T r a i n i n g   N e u r a l   N e t w o r k s .   W A C V .  
  
 S r i v a s t a v a ,   N . ,   H i n t o n ,   G . ,   K r i z h e v s k y ,   A . ,   S u t s k e v e r ,   I . ,   v d .   ( 2 0 1 4 ) .   D r o p o u t :   A   S i m p l e   W a y   t o   P r e v e n t   O v e r f i t t i n g .   J M L R .  
  
 G o o d f e l l o w ,   I . ,   S h l e n s ,   J . ,   &   S z e g e d y ,   C .   ( 2 0 1 5 ) .   E x p l a i n i n g   a n d   H a r n e s s i n g   A d v e r s a r i a l   E x a m p l e s .   I C L R .  
  
 C a r i o n ,   N . ,   M a s s a ,   F . ,   S y n n a e v e ,   G . ,   U s u n i e r ,   N . ,   v d .   ( 2 0 2 0 ) .   E n d - t o - E n d   O b j e c t   D e t e c t i o n   w i t h   T r a n s f o r m e r s .   E C C V .  
  
 K i e l a ,   D . ,   F i r o o z ,   H . ,   M o h a n ,   S . ,   G o s w a m i ,   V . ,   v d .   ( 2 0 2 0 ) .   T h e   H a t e f u l   M e m e s   C h a l l e n g e .   N e u r I P S .  
  
 D e a n ,   J . ,   &   B a r r o s o ,   L .   A .   ( 2 0 1 3 ) .   T h e   T a i l   a t   S c a l e .   C o m m u n i c a t i o n s   o f   t h e   A C M .  
  
 W o j k e ,   N . ,   B e w l e y ,   A . ,   &   P a u l u s ,   D .   ( 2 0 1 7 ) .   S i m p l e   O n l i n e   a n d   R e a l t i m e   T r a c k i n g   w i t h   a   D e e p   A s s o c i a t i o n   M e t r i c .   I C I P .  
  
 F e t t e ,   I . ,   &   M e l n i k o v ,   A .   ( 2 0 1 1 ) .   T h e   W e b S o c k e t   P r o t o c o l   ( R F C   6 4 5 5 ) .  
  
 N o r t h c u t t ,   C . ,   J i a n g ,   L . ,   &   C h u a n g ,   I .   ( 2 0 2 1 ) .   C o n f i d e n t   l e a r n i n g :   E s t i m a t i n g   u n c e r t a i n t y   i n   d a t a s e t   l a b e l s .   J A I R ,   7 0 ,   1 3 7 3 - 1 4 1 1 .  
  
 C h e n ,   P . ,   L i a o ,   B .   B . ,   C h e n ,   G . ,   &   Z h a n g ,   S .   ( 2 0 1 9 ) .   U n d e r s t a n d i n g   a n d   u t i l i z i n g   d e e p   n e u r a l   n e t w o r k s   t r a i n e d   w i t h   n o i s y   l a b e l s .  
  
 H a n ,   B . ,   Y a o ,   Q . ,   Y u ,   X . ,   N i u ,   G . ,   v d .   ( 2 0 1 8 ) .   C o - t e a c h i n g :   R o b u s t   t r a i n i n g   w i t h   e x t r e m e l y   n o i s y   l a b e l s .   N e u r I P S .  
  
 L i ,   J . ,   S o c h e r ,   R . ,   &   H o i ,   S .   C .   H .   ( 2 0 2 0 ) .   D i v i d e M i x :   L e a r n i n g   w i t h   n o i s y   l a b e l s   a s   s e m i - s u p e r v i s e d   l e a r n i n g .   I C L R .  
  
 Y u ,   X . ,   H a n ,   B . ,   Y a o ,   J . ,   N i u ,   G . ,   v d .   ( 2 0 1 9 ) .   H o w   d o e s   d i s a g r e e m e n t   h e l p   g e n e r a l i z a t i o n   a g a i n s t   l a b e l   c o r r u p t i o n ?   I C M L .  
  
 K h a t t a k ,   M .   U . ,   R a s h e e d ,   H . ,   M a a z ,   M . ,   K h a n ,   S . ,   &   K h a n ,   F .   S .   ( 2 0 2 3 ) .   M a P L e :   M u l t i - m o d a l   p r o m p t   l e a r n i n g .   C V P R .  
  
 L i n ,   H .   T . ,   L i n ,   C .   J . ,   &   W e n g ,   R .   C .   ( 2 0 0 7 ) .   A   n o t e   o n   P l a t t ' s   p r o b a b i l i s t i c   o u t p u t s .   M a c h i n e   L e a r n i n g ,   6 8 ,   2 6 7 - 2 7 6 .  
  
 S h o r t e n ,   C . ,   &   K h o s h g o f t a a r ,   T .   M .   ( 2 0 1 9 ) .   A   s u r v e y   o n   i m a g e   d a t a   a u g m e n t a t i o n .   J o u r n a l   o f   B i g   D a t a ,   6 ,   6 0 .  
  
 R e n ,   S . ,   H e ,   K . ,   G i r s h i c k ,   R . ,   &   S u n ,   J .   ( 2 0 1 5 ) .   F a s t e r   R - C N N :   T o w a r d s   r e a l - t i m e   o b j e c t   d e t e c t i o n .   N e u r I P S .  
  
 L o n g ,   J . ,   S h e l h a m e r ,   E . ,   &   D a r r e l l ,   T .   ( 2 0 1 5 ) .   F u l l y   c o n v o l u t i o n a l   n e t w o r k s   f o r   s e m a n t i c   s e g m e n t a t i o n .   C V P R .  
  
 S e l v a r a j u ,   R .   R . ,   C o g s w e l l ,   M . ,   D a s ,   A . ,   V e d a n t a m ,   R . ,   v d .   ( 2 0 1 7 ) .   G r a d - C A M :   V i s u a l   e x p l a n a t i o n s   f r o m   d e e p   n e t w o r k s .   I C C V .  
  
 K a r i m i ,   D . ,   D o u ,   H . ,   W a r f i e l d ,   S .   K . ,   &   G h o l i p o u r ,   A .   ( 2 0 2 0 ) .   D e e p   l e a r n i n g   w i t h   n o i s y   l a b e l s   i n   m e d i c a l   i m a g e   a n a l y s i s .   M e d i c a l   I m a g e   A n a l y s i s ,   6 5 ,   1 0 1 7 5 9 .  
  
 